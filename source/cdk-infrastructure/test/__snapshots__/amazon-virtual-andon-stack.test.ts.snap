// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`AVA Test Stack Snapshot 1`] = `
Object {
  "Conditions": Object {
    "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7": Object {
      "Fn::Equals": Array [
        Object {
          "Ref": "StartGlueWorkflow",
        },
        "Yes",
      ],
    },
    "BackEndExternalIntegrationsAnomalyDetectionBucketCondition1F7AF011": Object {
      "Fn::Not": Array [
        Object {
          "Fn::Equals": Array [
            Object {
              "Ref": "AnomalyDetectionBucketParameter",
            },
            "",
          ],
        },
      ],
    },
    "FrontEndCognitoDomainPrefixConditionABB3BBB6": Object {
      "Fn::Not": Array [
        Object {
          "Fn::Equals": Array [
            Object {
              "Ref": "CognitoDomainPrefixParameter",
            },
            "",
          ],
        },
      ],
    },
    "FrontEndCognitoSAMLConditionCF14CDB1": Object {
      "Fn::And": Array [
        Object {
          "Fn::Not": Array [
            Object {
              "Fn::Equals": Array [
                Object {
                  "Ref": "CognitoSAMLProviderNameParameter",
                },
                "",
              ],
            },
          ],
        },
        Object {
          "Fn::Not": Array [
            Object {
              "Fn::Equals": Array [
                Object {
                  "Ref": "CognitoSAMLProviderMetadataUrlParameter",
                },
                "",
              ],
            },
          ],
        },
      ],
    },
    "anomalyDetectionBucketParameterSetCondition": Object {
      "Fn::Equals": Array [
        Object {
          "Ref": "AnomalyDetectionBucketParameter",
        },
        "",
      ],
    },
    "cognitoDomainPrefixParameterSetCondition": Object {
      "Fn::Equals": Array [
        Object {
          "Ref": "CognitoDomainPrefixParameter",
        },
        "",
      ],
    },
    "cognitoSAMLProviderMetadataUrlParameterSetCondition": Object {
      "Fn::Equals": Array [
        Object {
          "Ref": "CognitoSAMLProviderMetadataUrlParameter",
        },
        "",
      ],
    },
    "cognitoSAMLProviderNameParameterSetCondition": Object {
      "Fn::Equals": Array [
        Object {
          "Ref": "CognitoSAMLProviderNameParameter",
        },
        "",
      ],
    },
  },
  "Description": "AVA Test Stack",
  "Mappings": Object {
    "Solution": Object {
      "Config": Object {
        "AnonymousUsage": "Yes",
        "S3BucketPrefix": "hosting-bucket",
        "S3KeyPrefix": "ava-test/v3.0.0",
        "SolutionId": "SOxyz",
        "Version": "v3.0.0",
      },
    },
  },
  "Metadata": Object {
    "AWS::CloudFormation::Interface": Object {
      "ParameterGroups": Array [
        Object {
          "Label": Object {
            "default": "Dashboard Configuration",
          },
          "Parameters": Array [
            "AdministratorEmail",
            "DefaultLanguage",
          ],
        },
        Object {
          "Label": Object {
            "default": "General Configuration",
          },
          "Parameters": Array [
            "LoggingLevel",
            "StartGlueWorkflow",
          ],
        },
        Object {
          "Label": Object {
            "default": "Lookout for Equipment Integration (Optional)",
          },
          "Parameters": Array [
            "AnomalyDetectionBucketParameter",
          ],
        },
        Object {
          "Label": Object {
            "default": "SAML Identity Provider Configuration (Optional)",
          },
          "Parameters": Array [
            "CognitoDomainPrefixParameter",
            "CognitoSAMLProviderNameParameter",
            "CognitoSAMLProviderMetadataUrlParameter",
          ],
        },
      ],
      "ParameterLabels": Object {
        "AdministratorEmail": Object {
          "default": "Administrator Email",
        },
        "AnomalyDetectionBucketParameter": Object {
          "default": "Anomaly Detection Output Bucket",
        },
        "CognitoDomainPrefixParameter": Object {
          "default": "Cognito Domain Prefix",
        },
        "CognitoSAMLProviderMetadataUrlParameter": Object {
          "default": "SAML Provider Metadata Url",
        },
        "CognitoSAMLProviderNameParameter": Object {
          "default": "SAML Provider Name",
        },
        "DefaultLanguage": Object {
          "default": "UI Default Language",
        },
        "LoggingLevel": Object {
          "default": "Log Level",
        },
        "StartGlueWorkflow": Object {
          "default": "Activate AWS Glue Workflow",
        },
      },
    },
  },
  "Outputs": Object {
    "AmazonVirtualAndonConsole": Object {
      "Description": "AVA Test console URL",
      "Value": Object {
        "Fn::Join": Array [
          "",
          Array [
            "https://",
            Object {
              "Fn::GetAtt": Array [
                "FrontEndDistributionToS3CloudFrontDistribution15FE13D0",
                "DomainName",
              ],
            },
          ],
        ],
      },
    },
    "CognitoDomain": Object {
      "Condition": "FrontEndCognitoDomainPrefixConditionABB3BBB6",
      "Description": "Cognito hosted domain",
      "Value": Object {
        "Fn::Join": Array [
          "",
          Array [
            "https://",
            Object {
              "Ref": "FrontEndUserPoolDomain4D30EABB",
            },
            ".auth.",
            Object {
              "Ref": "AWS::Region",
            },
            ".amazoncognito.com",
          ],
        ],
      },
    },
    "GraphQLEndpoint": Object {
      "Description": "Amazon Virtual Andon GraphQL endpoint",
      "Value": Object {
        "Fn::GetAtt": Array [
          "BackEndAppSyncApiGraphqlApi7F48FCAE",
          "GraphQLUrl",
        ],
      },
    },
    "SolutionVersion": Object {
      "Description": "SolutionVersion",
      "Value": "v3.0.0",
    },
    "UserPoolId": Object {
      "Condition": "FrontEndCognitoDomainPrefixConditionABB3BBB6",
      "Description": "Cognito User Pool ID",
      "Value": Object {
        "Ref": "FrontEndCognitoUserPoolFCECA826",
      },
    },
    "WebsiteAssetBucket": Object {
      "Description": "Amazon Virtual Andon web site assets bucket",
      "Value": Object {
        "Ref": "FrontEndDistributionToS3S3Bucket3A171D78",
      },
    },
  },
  "Parameters": Object {
    "AdministratorEmail": Object {
      "AllowedPattern": "^[_A-Za-z0-9-\\\\+]+(\\\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(\\\\.[A-Za-z0-9]+)*(\\\\.[A-Za-z]{2,})$",
      "ConstraintDescription": "Default User Email must be a valid email address",
      "Description": "(Required) Email address for Amazon Virtual Andon administrator.",
      "Type": "String",
    },
    "AnomalyDetectionBucketParameter": Object {
      "AllowedPattern": "^[a-z0-9.-]*$",
      "Default": "",
      "Description": "(Optional) The name of the Amazon S3 bucket which will contain anomaly detection files",
      "MaxLength": 63,
      "Type": "String",
    },
    "CognitoDomainPrefixParameter": Object {
      "AllowedPattern": "^$|^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?$",
      "Default": "",
      "Description": "(Optional) The prefix to the Cognito hosted domain name that will be associated with the user pool.",
      "Type": "String",
    },
    "CognitoSAMLProviderMetadataUrlParameter": Object {
      "Default": "",
      "Description": "(Optional) MetadataURL for the identity provider details.",
      "Type": "String",
    },
    "CognitoSAMLProviderNameParameter": Object {
      "AllowedPattern": "^[a-zA-Z]*$",
      "Default": "",
      "Description": "(Optional) The identity provider name.",
      "MaxLength": 32,
      "Type": "String",
    },
    "DefaultLanguage": Object {
      "AllowedValues": Array [
        "Browser Default",
        "Chinese (Simplified)",
        "English",
        "French (France)",
        "German",
        "Japanese",
        "Korean",
        "Spanish (Spain)",
        "Thai",
      ],
      "Default": "Browser Default",
      "Description": "Amazon Virtual Andon web interface default language. Choose \\"Browser Default\\" if you want to use your browser language as a default language.",
      "Type": "String",
    },
    "LoggingLevel": Object {
      "AllowedValues": Array [
        "VERBOSE",
        "DEBUG",
        "INFO",
        "WARN",
        "ERROR",
      ],
      "Default": "ERROR",
      "Description": "The logging level of the Lambda functions and the UI",
      "Type": "String",
    },
    "StartGlueWorkflow": Object {
      "AllowedValues": Array [
        "Yes",
        "No",
      ],
      "Default": "No",
      "Description": "Do you want to perform the Glue Workflow that will extract Amazon Virtual Andon's DynamoDB data to S3 for analysis with Athena? If set to 'Yes', the process will run every Monday at 1am UTC by default",
      "Type": "String",
    },
  },
  "Resources": Object {
    "AVADataHierarchyTable": Object {
      "DeletionPolicy": "Delete",
      "Properties": Object {
        "AttributeDefinitions": Array [
          Object {
            "AttributeName": "id",
            "AttributeType": "S",
          },
          Object {
            "AttributeName": "type",
            "AttributeType": "S",
          },
          Object {
            "AttributeName": "parentId",
            "AttributeType": "S",
          },
          Object {
            "AttributeName": "name",
            "AttributeType": "S",
          },
        ],
        "BillingMode": "PAY_PER_REQUEST",
        "GlobalSecondaryIndexes": Array [
          Object {
            "IndexName": "ByTypeAndParent-index",
            "KeySchema": Array [
              Object {
                "AttributeName": "type",
                "KeyType": "HASH",
              },
              Object {
                "AttributeName": "parentId",
                "KeyType": "RANGE",
              },
            ],
            "Projection": Object {
              "ProjectionType": "ALL",
            },
          },
          Object {
            "IndexName": "ByTypeAndName-index",
            "KeySchema": Array [
              Object {
                "AttributeName": "type",
                "KeyType": "HASH",
              },
              Object {
                "AttributeName": "name",
                "KeyType": "RANGE",
              },
            ],
            "Projection": Object {
              "ProjectionType": "ALL",
            },
          },
        ],
        "KeySchema": Array [
          Object {
            "AttributeName": "id",
            "KeyType": "HASH",
          },
          Object {
            "AttributeName": "type",
            "KeyType": "RANGE",
          },
        ],
        "PointInTimeRecoverySpecification": Object {
          "PointInTimeRecoveryEnabled": true,
        },
        "SSESpecification": Object {
          "SSEEnabled": true,
        },
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::DynamoDB::Table",
      "UpdateReplacePolicy": "Delete",
    },
    "AVAIssuesTable": Object {
      "DeletionPolicy": "Retain",
      "Properties": Object {
        "AttributeDefinitions": Array [
          Object {
            "AttributeName": "id",
            "AttributeType": "S",
          },
          Object {
            "AttributeName": "siteName",
            "AttributeType": "S",
          },
          Object {
            "AttributeName": "areaName#status#processName#stationName#deviceName#created",
            "AttributeType": "S",
          },
          Object {
            "AttributeName": "areaName#status#processName#eventDescription#stationName#deviceName#created",
            "AttributeType": "S",
          },
          Object {
            "AttributeName": "deviceName#eventId",
            "AttributeType": "S",
          },
          Object {
            "AttributeName": "createdDateUtc",
            "AttributeType": "S",
          },
          Object {
            "AttributeName": "createdAt",
            "AttributeType": "S",
          },
        ],
        "BillingMode": "PAY_PER_REQUEST",
        "GlobalSecondaryIndexes": Array [
          Object {
            "IndexName": "ByDevice-index",
            "KeySchema": Array [
              Object {
                "AttributeName": "siteName",
                "KeyType": "HASH",
              },
              Object {
                "AttributeName": "areaName#status#processName#stationName#deviceName#created",
                "KeyType": "RANGE",
              },
            ],
            "Projection": Object {
              "ProjectionType": "ALL",
            },
          },
          Object {
            "IndexName": "BySiteAreaStatus-index",
            "KeySchema": Array [
              Object {
                "AttributeName": "siteName",
                "KeyType": "HASH",
              },
              Object {
                "AttributeName": "areaName#status#processName#eventDescription#stationName#deviceName#created",
                "KeyType": "RANGE",
              },
            ],
            "Projection": Object {
              "ProjectionType": "ALL",
            },
          },
          Object {
            "IndexName": "ByDeviceEvent-index",
            "KeySchema": Array [
              Object {
                "AttributeName": "deviceName#eventId",
                "KeyType": "HASH",
              },
              Object {
                "AttributeName": "id",
                "KeyType": "RANGE",
              },
            ],
            "Projection": Object {
              "ProjectionType": "ALL",
            },
          },
          Object {
            "IndexName": "ByCreatedDate-index",
            "KeySchema": Array [
              Object {
                "AttributeName": "createdDateUtc",
                "KeyType": "HASH",
              },
              Object {
                "AttributeName": "createdAt",
                "KeyType": "RANGE",
              },
            ],
            "Projection": Object {
              "ProjectionType": "ALL",
            },
          },
        ],
        "KeySchema": Array [
          Object {
            "AttributeName": "id",
            "KeyType": "HASH",
          },
        ],
        "PointInTimeRecoverySpecification": Object {
          "PointInTimeRecoveryEnabled": true,
        },
        "SSESpecification": Object {
          "SSEEnabled": true,
        },
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::DynamoDB::Table",
      "UpdateReplacePolicy": "Retain",
    },
    "AvaGlueDataHierarchyTable": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "Properties": Object {
        "CatalogId": Object {
          "Ref": "AWS::AccountId",
        },
        "DatabaseName": Object {
          "Ref": "AvaGlueDatabase",
        },
        "TableInput": Object {
          "Parameters": Object {
            "EXTERNAL": "TRUE",
            "classification": "parquet",
            "has_encrypted_data": "false",
          },
          "StorageDescriptor": Object {
            "Columns": Array [
              Object {
                "Name": "protocol",
                "Type": "string",
              },
              Object {
                "Name": "endpoint",
                "Type": "string",
              },
              Object {
                "Name": "filterpolicy",
                "Type": "string",
              },
              Object {
                "Name": "id",
                "Type": "string",
              },
              Object {
                "Name": "type",
                "Type": "string",
              },
              Object {
                "Name": "subscriptionarn",
                "Type": "string",
              },
              Object {
                "Name": "stationareaid",
                "Type": "string",
              },
              Object {
                "Name": "createdat",
                "Type": "string",
              },
              Object {
                "Name": "name",
                "Type": "string",
              },
              Object {
                "Name": "description",
                "Type": "string",
              },
              Object {
                "Name": "version",
                "Type": "bigint",
              },
              Object {
                "Name": "parentid",
                "Type": "string",
              },
              Object {
                "Name": "updatedat",
                "Type": "string",
              },
              Object {
                "Name": "processareaid",
                "Type": "string",
              },
              Object {
                "Name": "eventprocessid",
                "Type": "string",
              },
              Object {
                "Name": "eventtype",
                "Type": "string",
              },
              Object {
                "Name": "priority",
                "Type": "string",
              },
              Object {
                "Name": "rootcauses",
                "Type": "string",
              },
              Object {
                "Name": "sms",
                "Type": "string",
              },
              Object {
                "Name": "eventimgkey",
                "Type": "string",
              },
              Object {
                "Name": "email",
                "Type": "string",
              },
              Object {
                "Name": "devicestationid",
                "Type": "string",
              },
              Object {
                "Name": "areasiteid",
                "Type": "string",
              },
              Object {
                "Name": "alias",
                "Type": "string",
              },
            ],
            "Compressed": false,
            "InputFormat": "org.apache.hadoop.mapred.TextInputFormat",
            "Location": Object {
              "Fn::Join": Array [
                "",
                Array [
                  "s3://",
                  Object {
                    "Ref": "AvaGlueOutputBucket",
                  },
                  "/glue/ddb-output/data-hierarchy",
                ],
              ],
            },
            "NumberOfBuckets": -1,
            "OutputFormat": "org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat",
            "SerdeInfo": Object {
              "Parameters": Object {
                "serialization.format": "1",
              },
              "SerializationLibrary": "org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe",
            },
            "StoredAsSubDirectories": false,
          },
          "TableType": "EXTERNAL_TABLE",
        },
      },
      "Type": "AWS::Glue::Table",
    },
    "AvaGlueDatabase": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "Properties": Object {
        "CatalogId": Object {
          "Ref": "AWS::AccountId",
        },
        "DatabaseInput": Object {
          "Name": "amazon-virtual-andon-glue-database",
        },
      },
      "Type": "AWS::Glue::Database",
    },
    "AvaGlueIssuesTable": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "Properties": Object {
        "CatalogId": Object {
          "Ref": "AWS::AccountId",
        },
        "DatabaseName": Object {
          "Ref": "AvaGlueDatabase",
        },
        "TableInput": Object {
          "Parameters": Object {
            "EXTERNAL": "TRUE",
            "classification": "parquet",
            "has_encrypted_data": "false",
          },
          "StorageDescriptor": Object {
            "Columns": Array [
              Object {
                "Name": "eventid",
                "Type": "string",
              },
              Object {
                "Name": "acknowledged",
                "Type": "string",
              },
              Object {
                "Name": "created",
                "Type": "string",
              },
              Object {
                "Name": "sitename",
                "Type": "string",
              },
              Object {
                "Name": "issuesource",
                "Type": "string",
              },
              Object {
                "Name": "priority",
                "Type": "string",
              },
              Object {
                "Name": "areaname#status#processname#eventdescription#stationname#devicename#created",
                "Type": "string",
              },
              Object {
                "Name": "version",
                "Type": "bigint",
              },
              Object {
                "Name": "devicename",
                "Type": "string",
              },
              Object {
                "Name": "devicename#eventid",
                "Type": "string",
              },
              Object {
                "Name": "createdat",
                "Type": "string",
              },
              Object {
                "Name": "areaname",
                "Type": "string",
              },
              Object {
                "Name": "processname",
                "Type": "string",
              },
              Object {
                "Name": "createddateutc",
                "Type": "date",
              },
              Object {
                "Name": "eventdescription",
                "Type": "string",
              },
              Object {
                "Name": "areaname#status#processname#stationname#devicename#created",
                "Type": "string",
              },
              Object {
                "Name": "stationname",
                "Type": "string",
              },
              Object {
                "Name": "id",
                "Type": "string",
              },
              Object {
                "Name": "acknowledgedtime",
                "Type": "bigint",
              },
              Object {
                "Name": "status",
                "Type": "string",
              },
              Object {
                "Name": "updatedat",
                "Type": "string",
              },
              Object {
                "Name": "closed",
                "Type": "string",
              },
              Object {
                "Name": "resolutiontime",
                "Type": "bigint",
              },
              Object {
                "Name": "createdby",
                "Type": "string",
              },
              Object {
                "Name": "acknowledgedby",
                "Type": "string",
              },
              Object {
                "Name": "closedby",
                "Type": "string",
              },
              Object {
                "Name": "rejectedby",
                "Type": "string",
              },
              Object {
                "Name": "additionaldetails",
                "Type": "string",
              },
            ],
            "Compressed": false,
            "InputFormat": "org.apache.hadoop.mapred.TextInputFormat",
            "Location": Object {
              "Fn::Join": Array [
                "",
                Array [
                  "s3://",
                  Object {
                    "Ref": "AvaGlueOutputBucket",
                  },
                  "/glue/ddb-output/issues",
                ],
              ],
            },
            "NumberOfBuckets": -1,
            "OutputFormat": "org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat",
            "SerdeInfo": Object {
              "Parameters": Object {
                "serialization.format": "1",
              },
              "SerializationLibrary": "org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe",
            },
            "StoredAsSubDirectories": false,
          },
          "TableType": "EXTERNAL_TABLE",
        },
      },
      "Type": "AWS::Glue::Table",
    },
    "AvaGlueOutputBucket": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "DeletionPolicy": "Retain",
      "Properties": Object {
        "BucketEncryption": Object {
          "ServerSideEncryptionConfiguration": Array [
            Object {
              "ServerSideEncryptionByDefault": Object {
                "SSEAlgorithm": "AES256",
              },
            },
          ],
        },
        "LoggingConfiguration": Object {
          "DestinationBucketName": Object {
            "Ref": "CommonResourcesLogBucketFC1ABCC9",
          },
          "LogFilePrefix": "glue-output/",
        },
        "PublicAccessBlockConfiguration": Object {
          "BlockPublicAcls": true,
          "BlockPublicPolicy": true,
          "IgnorePublicAcls": true,
          "RestrictPublicBuckets": true,
        },
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::S3::Bucket",
      "UpdateReplacePolicy": "Retain",
    },
    "BackEndAppSyncApiAppSyncResolverLambdaFunctionE084D1FB": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiAppSyncResolverLambdaFunctionRole68A09CEC",
      ],
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "W89",
              "reason": "VPC for Lambda is not needed. This serverless architecture does not deploy a VPC.",
            },
            Object {
              "id": "W92",
              "reason": "ReservedConcurrentExecutions is not needed for this Lambda function.",
            },
          ],
        },
      },
      "Properties": Object {
        "Code": Object {
          "S3Bucket": Object {
            "Fn::Join": Array [
              "",
              Array [
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3BucketPrefix",
                  ],
                },
                "-",
                Object {
                  "Ref": "AWS::Region",
                },
              ],
            ],
          },
          "S3Key": Object {
            "Fn::Join": Array [
              "",
              Array [
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3KeyPrefix",
                  ],
                },
                "/appsync-lambda-resolver.zip",
              ],
            ],
          },
        },
        "Description": "AVA Test (v3.0.0): Resolver for various AppSync functions",
        "Environment": Object {
          "Variables": Object {
            "DATA_HIERARCHY_TABLE_NAME": Object {
              "Ref": "AVADataHierarchyTable",
            },
            "ISSUES_TABLE_NAME": Object {
              "Ref": "AVAIssuesTable",
            },
            "ISSUE_NOTIFICATION_TOPIC_ARN": Object {
              "Ref": "IssueNotificationTopic",
            },
            "LOGGING_LEVEL": Object {
              "Ref": "LoggingLevel",
            },
          },
        },
        "Handler": "appsync-lambda-resolver/index.handler",
        "Role": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiAppSyncResolverLambdaFunctionRole68A09CEC",
            "Arn",
          ],
        },
        "Runtime": "nodejs14.x",
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
        "Timeout": 60,
      },
      "Type": "AWS::Lambda::Function",
    },
    "BackEndAppSyncApiAppSyncResolverLambdaFunctionRole68A09CEC": Object {
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "Service": "lambda.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "Path": "/",
        "Policies": Array [
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": Array [
                    "sns:Subscribe",
                    "sns:Unsubscribe",
                    "sns:SetSubscriptionAttributes",
                  ],
                  "Effect": "Allow",
                  "Resource": Object {
                    "Ref": "IssueNotificationTopic",
                  },
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "SnsPolicy",
          },
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": Array [
                    "dynamodb:GetItem",
                    "dynamodb:PutItem",
                  ],
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::GetAtt": Array [
                      "AVADataHierarchyTable",
                      "Arn",
                    ],
                  },
                },
                Object {
                  "Action": "dynamodb:Query",
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        Object {
                          "Fn::GetAtt": Array [
                            "AVAIssuesTable",
                            "Arn",
                          ],
                        },
                        "/index/ByCreatedDate-index",
                      ],
                    ],
                  },
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "DynamoDbPolicy",
          },
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": Array [
                    "logs:CreateLogGroup",
                    "logs:CreateLogStream",
                    "logs:PutLogEvents",
                  ],
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        "arn:",
                        Object {
                          "Ref": "AWS::Partition",
                        },
                        ":logs:",
                        Object {
                          "Ref": "AWS::Region",
                        },
                        ":",
                        Object {
                          "Ref": "AWS::AccountId",
                        },
                        ":log-group:/aws/lambda/*",
                      ],
                    ],
                  },
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "CloudWatchLogsPolicy",
          },
        ],
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "BackEndAppSyncApiGraphqlApi7F48FCAE": Object {
      "Properties": Object {
        "AdditionalAuthenticationProviders": Array [
          Object {
            "AuthenticationType": "AWS_IAM",
          },
        ],
        "AuthenticationType": "AMAZON_COGNITO_USER_POOLS",
        "LogConfig": Object {
          "CloudWatchLogsRoleArn": Object {
            "Fn::GetAtt": Array [
              "BackEndAppSyncApiLogRoleD851D1DD",
              "Arn",
            ],
          },
          "ExcludeVerboseContent": false,
          "FieldLogLevel": "NONE",
        },
        "Name": "ava-api",
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
        "UserPoolConfig": Object {
          "AwsRegion": Object {
            "Ref": "AWS::Region",
          },
          "DefaultAction": "ALLOW",
          "UserPoolId": Object {
            "Ref": "FrontEndCognitoUserPoolFCECA826",
          },
        },
      },
      "Type": "AWS::AppSync::GraphQLApi",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608": Object {
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DynamoDBConfig": Object {
          "AwsRegion": Object {
            "Ref": "AWS::Region",
          },
          "TableName": Object {
            "Ref": "AVADataHierarchyTable",
          },
        },
        "Name": "AVADataSource",
        "ServiceRoleArn": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApiAVADataSourceServiceRole91F4DE80",
            "Arn",
          ],
        },
        "Type": "AMAZON_DYNAMODB",
      },
      "Type": "AWS::AppSync::DataSource",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceAreaprocessResolver3FCFA3A1": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "process",
        "Kind": "UNIT",
        "RequestMappingTemplate": "#set( $limit = $util.defaultIfNull($context.args.limit, 10) )
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"query\\": {
    \\"expressionNames\\": {
      \\"#type\\": \\"type\\",
      \\"#parent\\": \\"parentId\\"
    },
    \\"expressionValues\\": {
      \\":type\\": $util.dynamodb.toDynamoDBJson(\\"PROCESS\\"),
      \\":parent\\": $util.dynamodb.toDynamoDBJson($ctx.source.id)
    },
    \\"expression\\": \\"#type = :type and #parent = :parent\\"
  },
  \\"scanIndexForward\\":   #if( $context.args.sortDirection )
    #if( $context.args.sortDirection == \\"ASC\\" )
true
    #else
false
    #end
  #else
true
  #end,
  \\"filter\\":   #if( $context.args.filter )
$util.transform.toDynamoDBFilterExpression($ctx.args.filter)
  #else
null
  #end,
  \\"limit\\": $limit,
  \\"nextToken\\":   #if( $context.args.nextToken )
\\"$context.args.nextToken\\"
  #else
null
  #end,
  \\"index\\": \\"ByTypeAndParent-index\\"
}
",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Area",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceAreasiteResolver8DE07256": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "site",
        "Kind": "UNIT",
        "RequestMappingTemplate": "{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
      \\"id\\": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.source.areaSiteId, \\"___xamznone____\\")),
      \\"type\\": $util.dynamodb.toDynamoDBJson(\\"SITE\\")
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Area",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceAreastationResolver84A28BFA": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "station",
        "Kind": "UNIT",
        "RequestMappingTemplate": "#set( $limit = $util.defaultIfNull($context.args.limit, 10) )
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"query\\": {
    \\"expressionNames\\": {
      \\"#type\\": \\"type\\",
      \\"#parent\\": \\"parentId\\"
    },
    \\"expressionValues\\": {
      \\":type\\": $util.dynamodb.toDynamoDBJson(\\"STATION\\"),
      \\":parent\\": $util.dynamodb.toDynamoDBJson($ctx.source.id)
    },
    \\"expression\\": \\"#type = :type and #parent = :parent\\"
  },
  \\"scanIndexForward\\":   #if( $context.args.sortDirection )
    #if( $context.args.sortDirection == \\"ASC\\" )
true
    #else
false
    #end
  #else
true
  #end,
  \\"filter\\":   #if( $context.args.filter )
$util.transform.toDynamoDBFilterExpression($ctx.args.filter)
  #else
null
  #end,
  \\"limit\\": $limit,
  \\"nextToken\\":   #if( $context.args.nextToken )
\\"$context.args.nextToken\\"
  #else
null
  #end,
  \\"index\\": \\"ByTypeAndParent-index\\"
}
",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Area",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceCreateAreaFunctionFunctionED44AF26": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Create an area",
        "FunctionVersion": "2018-05-29",
        "Name": "CreateAreaFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## Check duplication
#set ($duplicated = $ctx.prev.result.items)
#if ($duplicated.size() > 0)
  #if ($ctx.args.rootCause)
    $util.error(\\"Same root cause already exists.\\", \\"DataDuplicatedError\\")
  #else
    $util.error(\\"Same name already exists.\\", \\"DataDuplicatedError\\")
  #end
#end

## Check validation
#if ($ctx.args.sms)
  #if (!$util.matches(\\"^((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4})(,\\\\s*((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4}))*$\\", $ctx.args.sms))
    $util.error(\\"SMS No. must be a comma-separated list of valid phone numbers.\\")
  #end
#end
#if ($ctx.args.email)
  #if (!$util.matches(\\"^([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+)(,\\\\s*([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+))*$\\", $ctx.args.email))
    $util.error(\\"E-Mail must be a comma-separated list of valid E-Mail addresses.\\")
  #end
#end

## Set default values
$util.qr($ctx.args.put(\\"version\\", $util.defaultIfNull($ctx.args.version, 1)))
$util.qr($ctx.args.put(\\"createdAt\\", $util.defaultIfNull($ctx.args.createdAt, $util.time.nowISO8601())))
$util.qr($ctx.args.put(\\"updatedAt\\", $util.defaultIfNull($ctx.args.updatedAt, $util.time.nowISO8601())))
#if ($ctx.args.type == \\"AREA\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.areaSiteId))
#end
#if ($ctx.args.type == \\"STATION\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.stationAreaId))
#end
#if ($ctx.args.type == \\"DEVICE\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.deviceStationId))
#end
#if ($ctx.args.type == \\"PROCESS\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.processAreaId))
#end
#if ($ctx.args.type == \\"EVENT\\")
  #if ( ! $ctx.args.parentId)
    ## If the parentId does not exist, this is a top-level event so use the process ID as the parentId
    $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.eventProcessId))
  #end
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"PutItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.id, $util.autoId())),
    \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type),
  },
  \\"attributeValues\\": $util.dynamodb.toMapValuesJson($context.args)
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceCreateDeviceFunctionFunction7ED8FEDE": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Create a device",
        "FunctionVersion": "2018-05-29",
        "Name": "CreateDeviceFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## Check duplication
#set ($duplicated = $ctx.prev.result.items)
#if ($duplicated.size() > 0)
  #if ($ctx.args.rootCause)
    $util.error(\\"Same root cause already exists.\\", \\"DataDuplicatedError\\")
  #else
    $util.error(\\"Same name already exists.\\", \\"DataDuplicatedError\\")
  #end
#end

## Check validation
#if ($ctx.args.sms)
  #if (!$util.matches(\\"^((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4})(,\\\\s*((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4}))*$\\", $ctx.args.sms))
    $util.error(\\"SMS No. must be a comma-separated list of valid phone numbers.\\")
  #end
#end
#if ($ctx.args.email)
  #if (!$util.matches(\\"^([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+)(,\\\\s*([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+))*$\\", $ctx.args.email))
    $util.error(\\"E-Mail must be a comma-separated list of valid E-Mail addresses.\\")
  #end
#end

## Set default values
$util.qr($ctx.args.put(\\"version\\", $util.defaultIfNull($ctx.args.version, 1)))
$util.qr($ctx.args.put(\\"createdAt\\", $util.defaultIfNull($ctx.args.createdAt, $util.time.nowISO8601())))
$util.qr($ctx.args.put(\\"updatedAt\\", $util.defaultIfNull($ctx.args.updatedAt, $util.time.nowISO8601())))
#if ($ctx.args.type == \\"AREA\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.areaSiteId))
#end
#if ($ctx.args.type == \\"STATION\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.stationAreaId))
#end
#if ($ctx.args.type == \\"DEVICE\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.deviceStationId))
#end
#if ($ctx.args.type == \\"PROCESS\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.processAreaId))
#end
#if ($ctx.args.type == \\"EVENT\\")
  #if ( ! $ctx.args.parentId)
    ## If the parentId does not exist, this is a top-level event so use the process ID as the parentId
    $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.eventProcessId))
  #end
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"PutItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.id, $util.autoId())),
    \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type),
  },
  \\"attributeValues\\": $util.dynamodb.toMapValuesJson($context.args)
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceCreateEventFunctionFunctionE89A7134": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Create an event",
        "FunctionVersion": "2018-05-29",
        "Name": "CreateEventFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## Check duplication
#set ($duplicated = $ctx.prev.result.items)
#if ($duplicated.size() > 0)
  #if ($ctx.args.rootCause)
    $util.error(\\"Same root cause already exists.\\", \\"DataDuplicatedError\\")
  #else
    $util.error(\\"Same name already exists.\\", \\"DataDuplicatedError\\")
  #end
#end

## Check validation
#if ($ctx.args.sms)
  #if (!$util.matches(\\"^((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4})(,\\\\s*((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4}))*$\\", $ctx.args.sms))
    $util.error(\\"SMS No. must be a comma-separated list of valid phone numbers.\\")
  #end
#end
#if ($ctx.args.email)
  #if (!$util.matches(\\"^([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+)(,\\\\s*([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+))*$\\", $ctx.args.email))
    $util.error(\\"E-Mail must be a comma-separated list of valid E-Mail addresses.\\")
  #end
#end

## Set default values
$util.qr($ctx.args.put(\\"version\\", $util.defaultIfNull($ctx.args.version, 1)))
$util.qr($ctx.args.put(\\"createdAt\\", $util.defaultIfNull($ctx.args.createdAt, $util.time.nowISO8601())))
$util.qr($ctx.args.put(\\"updatedAt\\", $util.defaultIfNull($ctx.args.updatedAt, $util.time.nowISO8601())))
#if ($ctx.args.type == \\"AREA\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.areaSiteId))
#end
#if ($ctx.args.type == \\"STATION\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.stationAreaId))
#end
#if ($ctx.args.type == \\"DEVICE\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.deviceStationId))
#end
#if ($ctx.args.type == \\"PROCESS\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.processAreaId))
#end
#if ($ctx.args.type == \\"EVENT\\")
  #if ( ! $ctx.args.parentId)
    ## If the parentId does not exist, this is a top-level event so use the process ID as the parentId
    $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.eventProcessId))
  #end
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"PutItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.id, $util.autoId())),
    \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type),
  },
  \\"attributeValues\\": $util.dynamodb.toMapValuesJson($context.args)
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceCreateProcessFunctionFunctionEF12FD3D": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Create a process",
        "FunctionVersion": "2018-05-29",
        "Name": "CreateProcessFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## Check duplication
#set ($duplicated = $ctx.prev.result.items)
#if ($duplicated.size() > 0)
  #if ($ctx.args.rootCause)
    $util.error(\\"Same root cause already exists.\\", \\"DataDuplicatedError\\")
  #else
    $util.error(\\"Same name already exists.\\", \\"DataDuplicatedError\\")
  #end
#end

## Check validation
#if ($ctx.args.sms)
  #if (!$util.matches(\\"^((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4})(,\\\\s*((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4}))*$\\", $ctx.args.sms))
    $util.error(\\"SMS No. must be a comma-separated list of valid phone numbers.\\")
  #end
#end
#if ($ctx.args.email)
  #if (!$util.matches(\\"^([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+)(,\\\\s*([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+))*$\\", $ctx.args.email))
    $util.error(\\"E-Mail must be a comma-separated list of valid E-Mail addresses.\\")
  #end
#end

## Set default values
$util.qr($ctx.args.put(\\"version\\", $util.defaultIfNull($ctx.args.version, 1)))
$util.qr($ctx.args.put(\\"createdAt\\", $util.defaultIfNull($ctx.args.createdAt, $util.time.nowISO8601())))
$util.qr($ctx.args.put(\\"updatedAt\\", $util.defaultIfNull($ctx.args.updatedAt, $util.time.nowISO8601())))
#if ($ctx.args.type == \\"AREA\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.areaSiteId))
#end
#if ($ctx.args.type == \\"STATION\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.stationAreaId))
#end
#if ($ctx.args.type == \\"DEVICE\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.deviceStationId))
#end
#if ($ctx.args.type == \\"PROCESS\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.processAreaId))
#end
#if ($ctx.args.type == \\"EVENT\\")
  #if ( ! $ctx.args.parentId)
    ## If the parentId does not exist, this is a top-level event so use the process ID as the parentId
    $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.eventProcessId))
  #end
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"PutItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.id, $util.autoId())),
    \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type),
  },
  \\"attributeValues\\": $util.dynamodb.toMapValuesJson($context.args)
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceCreateRootCauseFunctionFunction7844347F": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Create a root cause",
        "FunctionVersion": "2018-05-29",
        "Name": "CreateRootCauseFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## Check duplication
#set ($duplicated = $ctx.prev.result.items)
#if ($duplicated.size() > 0)
  #if ($ctx.args.rootCause)
    $util.error(\\"Same root cause already exists.\\", \\"DataDuplicatedError\\")
  #else
    $util.error(\\"Same name already exists.\\", \\"DataDuplicatedError\\")
  #end
#end

## Check validation
#if ($ctx.args.sms)
  #if (!$util.matches(\\"^((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4})(,\\\\s*((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4}))*$\\", $ctx.args.sms))
    $util.error(\\"SMS No. must be a comma-separated list of valid phone numbers.\\")
  #end
#end
#if ($ctx.args.email)
  #if (!$util.matches(\\"^([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+)(,\\\\s*([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+))*$\\", $ctx.args.email))
    $util.error(\\"E-Mail must be a comma-separated list of valid E-Mail addresses.\\")
  #end
#end

## Set default values
$util.qr($ctx.args.put(\\"version\\", $util.defaultIfNull($ctx.args.version, 1)))
$util.qr($ctx.args.put(\\"createdAt\\", $util.defaultIfNull($ctx.args.createdAt, $util.time.nowISO8601())))
$util.qr($ctx.args.put(\\"updatedAt\\", $util.defaultIfNull($ctx.args.updatedAt, $util.time.nowISO8601())))
#if ($ctx.args.type == \\"AREA\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.areaSiteId))
#end
#if ($ctx.args.type == \\"STATION\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.stationAreaId))
#end
#if ($ctx.args.type == \\"DEVICE\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.deviceStationId))
#end
#if ($ctx.args.type == \\"PROCESS\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.processAreaId))
#end
#if ($ctx.args.type == \\"EVENT\\")
  #if ( ! $ctx.args.parentId)
    ## If the parentId does not exist, this is a top-level event so use the process ID as the parentId
    $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.eventProcessId))
  #end
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"PutItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.id, $util.autoId())),
    \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type),
  },
  \\"attributeValues\\": $util.dynamodb.toMapValuesJson($context.args)
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceCreateSiteFunctionFunctionEA8154A6": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Create a site",
        "FunctionVersion": "2018-05-29",
        "Name": "CreateSiteFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## Check duplication
#set ($duplicated = $ctx.prev.result.items)
#if ($duplicated.size() > 0)
  #if ($ctx.args.rootCause)
    $util.error(\\"Same root cause already exists.\\", \\"DataDuplicatedError\\")
  #else
    $util.error(\\"Same name already exists.\\", \\"DataDuplicatedError\\")
  #end
#end

## Check validation
#if ($ctx.args.sms)
  #if (!$util.matches(\\"^((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4})(,\\\\s*((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4}))*$\\", $ctx.args.sms))
    $util.error(\\"SMS No. must be a comma-separated list of valid phone numbers.\\")
  #end
#end
#if ($ctx.args.email)
  #if (!$util.matches(\\"^([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+)(,\\\\s*([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+))*$\\", $ctx.args.email))
    $util.error(\\"E-Mail must be a comma-separated list of valid E-Mail addresses.\\")
  #end
#end

## Set default values
$util.qr($ctx.args.put(\\"version\\", $util.defaultIfNull($ctx.args.version, 1)))
$util.qr($ctx.args.put(\\"createdAt\\", $util.defaultIfNull($ctx.args.createdAt, $util.time.nowISO8601())))
$util.qr($ctx.args.put(\\"updatedAt\\", $util.defaultIfNull($ctx.args.updatedAt, $util.time.nowISO8601())))
#if ($ctx.args.type == \\"AREA\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.areaSiteId))
#end
#if ($ctx.args.type == \\"STATION\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.stationAreaId))
#end
#if ($ctx.args.type == \\"DEVICE\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.deviceStationId))
#end
#if ($ctx.args.type == \\"PROCESS\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.processAreaId))
#end
#if ($ctx.args.type == \\"EVENT\\")
  #if ( ! $ctx.args.parentId)
    ## If the parentId does not exist, this is a top-level event so use the process ID as the parentId
    $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.eventProcessId))
  #end
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"PutItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.id, $util.autoId())),
    \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type),
  },
  \\"attributeValues\\": $util.dynamodb.toMapValuesJson($context.args)
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceCreateStationFunctionFunction2E6FB5D2": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Create a station",
        "FunctionVersion": "2018-05-29",
        "Name": "CreateStationFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## Check duplication
#set ($duplicated = $ctx.prev.result.items)
#if ($duplicated.size() > 0)
  #if ($ctx.args.rootCause)
    $util.error(\\"Same root cause already exists.\\", \\"DataDuplicatedError\\")
  #else
    $util.error(\\"Same name already exists.\\", \\"DataDuplicatedError\\")
  #end
#end

## Check validation
#if ($ctx.args.sms)
  #if (!$util.matches(\\"^((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4})(,\\\\s*((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4}))*$\\", $ctx.args.sms))
    $util.error(\\"SMS No. must be a comma-separated list of valid phone numbers.\\")
  #end
#end
#if ($ctx.args.email)
  #if (!$util.matches(\\"^([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+)(,\\\\s*([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+))*$\\", $ctx.args.email))
    $util.error(\\"E-Mail must be a comma-separated list of valid E-Mail addresses.\\")
  #end
#end

## Set default values
$util.qr($ctx.args.put(\\"version\\", $util.defaultIfNull($ctx.args.version, 1)))
$util.qr($ctx.args.put(\\"createdAt\\", $util.defaultIfNull($ctx.args.createdAt, $util.time.nowISO8601())))
$util.qr($ctx.args.put(\\"updatedAt\\", $util.defaultIfNull($ctx.args.updatedAt, $util.time.nowISO8601())))
#if ($ctx.args.type == \\"AREA\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.areaSiteId))
#end
#if ($ctx.args.type == \\"STATION\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.stationAreaId))
#end
#if ($ctx.args.type == \\"DEVICE\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.deviceStationId))
#end
#if ($ctx.args.type == \\"PROCESS\\")
  $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.processAreaId))
#end
#if ($ctx.args.type == \\"EVENT\\")
  #if ( ! $ctx.args.parentId)
    ## If the parentId does not exist, this is a top-level event so use the process ID as the parentId
    $util.qr($ctx.args.put(\\"parentId\\", $ctx.args.eventProcessId))
  #end
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"PutItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.id, $util.autoId())),
    \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type),
  },
  \\"attributeValues\\": $util.dynamodb.toMapValuesJson($context.args)
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceDeleteEventFunctionFunctionDB61489B": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Delete an event",
        "FunctionVersion": "2018-05-29",
        "Name": "DeleteEventFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"DeleteItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
    \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type)
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceDevicestationResolver50CA5C5E": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "station",
        "Kind": "UNIT",
        "RequestMappingTemplate": "{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
      \\"id\\": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.source.deviceStationId, \\"___xamznone____\\")),
      \\"type\\": $util.dynamodb.toDynamoDBJson(\\"STATION\\")
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Device",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceEventprocessResolver5C10C20B": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "process",
        "Kind": "UNIT",
        "RequestMappingTemplate": "{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
      \\"id\\": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.source.eventProcessId, \\"___xamznone____\\")),
      \\"type\\": $util.dynamodb.toDynamoDBJson(\\"PROCESS\\")
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Event",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceGetPermissionsForAssociateGroupUserFunctionFunctionDF3C35D5": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Get permissions for an associate group user",
        "FunctionVersion": "2018-05-29",
        "Name": "GetPermissionsForAssociateGroupUserFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])

## If the request is to get a site, an area, a station, or a process, only AdminGroup can access the data.
## The other case would be getting a user permission by every group users.
#if ($ctx.args.id)
  ## For 'getEvent' and 'getPermission', do not restrict to only the AdminGroup
  #if ($ctx.info.fieldName != \\"getEvent\\" && $ctx.info.fieldName != \\"getPermission\\")
    #set ($allowedGroups = [\\"AdminGroup\\"])
  #end
#end

#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## If it needs to get permission, and the user is only in AssociateGroup, get permission.
#if ($ctx.stash.permissionCheck)
  #if ($userGroups.size() == 1 && $userGroups.contains(\\"AssociateGroup\\"))
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
    \\"id\\": { \\"S\\": \\"$ctx.identity.sub\\" },
    \\"type\\": $util.dynamodb.toDynamoDBJson(\\"PERMISSION\\")
  }
}
  #else
    #return({})
  #end
#else
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
  \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
  \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type)
  }
}
#end",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceListAreasFunctionFunctionC29C1C3E": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Get areas",
        "FunctionVersion": "2018-05-29",
        "Name": "ListAreasFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"query\\": {
    \\"expressionNames\\": {
      \\"#type\\": \\"type\\",
      \\"#parent\\": \\"parentId\\"
    },
    \\"expressionValues\\": {
      \\":type\\": $util.dynamodb.toDynamoDBJson(\\"AREA\\"),
      \\":parent\\": $util.dynamodb.toDynamoDBJson($ctx.args.areaSiteId)
    },
    \\"expression\\": \\"#type = :type and #parent = :parent\\"
  },
  #if( $context.args.name )
    \\"filter\\": {
      \\"expression\\" : \\"#name = :name\\",
      \\"expressionNames\\" : {
          \\"#name\\" : \\"name\\"
      },
      \\"expressionValues\\" : {
          \\":name\\" : { \\"S\\" : \\"$ctx.args.name\\" }
      }
    },
  #end
  \\"index\\": \\"ByTypeAndParent-index\\",
  #if ($ctx.args.nextToken)
    \\"nextToken\\": \\"$ctx.args.nextToken\\",
  #end
  \\"limit\\": $util.defaultIfNull($ctx.args.limit, 50)
}
",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceListDevicesFunctionFunction0FAC671B": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Get devices",
        "FunctionVersion": "2018-05-29",
        "Name": "ListDevicesFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"query\\": {
    \\"expression\\": \\"#type = :type and #parent = :parent\\",
    \\"expressionNames\\": {
      \\"#type\\": \\"type\\",
      \\"#parent\\": \\"parentId\\"
    },
    \\"expressionValues\\": {
      \\":type\\": $util.dynamodb.toDynamoDBJson(\\"DEVICE\\"),
      \\":parent\\": $util.dynamodb.toDynamoDBJson($ctx.args.deviceStationId)
    },
  },
  #if( $context.args.name )
    \\"filter\\": {
      \\"expression\\" : \\"#name = :name\\",
      \\"expressionNames\\" : {
          \\"#name\\" : \\"name\\"
      },
      \\"expressionValues\\" : {
          \\":name\\" : { \\"S\\" : \\"$ctx.args.name\\" }
      }
    },
  #end
  \\"index\\": \\"ByTypeAndParent-index\\",
  #if( $ctx.args.nextToken )
    \\"nextToken\\": \\"$ctx.args.nextToken\\",
  #end
  \\"limit\\": $util.defaultIfNull($ctx.args.limit, 50)
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceListEventsFunctionFunctionD03130CF": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Get events",
        "FunctionVersion": "2018-05-29",
        "Name": "ListEventsFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"query\\": {
    \\"expressionNames\\": {
      \\"#type\\": \\"type\\",
      #if( $context.args.parentId ) \\"#parent\\": \\"parentId\\" #end
    },
    \\"expressionValues\\": {
      \\":type\\": $util.dynamodb.toDynamoDBJson(\\"EVENT\\"),
      #if( $context.args.parentId ) \\":parent\\": $util.dynamodb.toDynamoDBJson($ctx.args.parentId) #end
    },
    \\"expression\\": \\"#type = :type #if( $context.args.parentId ) and #parent = :parent #end\\"
  },
  #if( $context.args.name || $context.args.eventProcessId )
    \\"filter\\": {
      #if( $context.args.name && $context.args.eventProcessId )
        \\"expression\\" : \\"#name = :name and #process = :process\\",
      #elseif( $context.args.name )
        \\"expression\\" : \\"#name = :name\\",
      #else
        \\"expression\\" : \\"#process = :process\\",
      #end
      \\"expressionNames\\" : {
          #if( $context.args.name ) \\"#name\\" : \\"name\\", #end
          #if( $context.args.eventProcessId ) \\"#process\\" : \\"eventProcessId\\", #end
      },
      \\"expressionValues\\" : {
          #if( $context.args.name ) \\":name\\" : { \\"S\\" : \\"$ctx.args.name\\" }, #end
          #if( $context.args.eventProcessId ) \\":process\\" : { \\"S\\" : \\"$ctx.args.eventProcessId\\" }, #end
      }
    },
  #end
  \\"index\\": \\"ByTypeAndParent-index\\",
  #if ($ctx.args.nextToken)
    \\"nextToken\\": \\"$ctx.args.nextToken\\",
  #end
  \\"limit\\": $util.defaultIfNull($ctx.args.limit, 20)
}
",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceListProcessesFunctionFunctionAE27334B": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Get processes",
        "FunctionVersion": "2018-05-29",
        "Name": "ListProcessesFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"query\\": {
    \\"expressionNames\\": {
      \\"#type\\": \\"type\\",
      \\"#parent\\": \\"parentId\\"
    },
    \\"expressionValues\\": {
      \\":type\\": $util.dynamodb.toDynamoDBJson(\\"PROCESS\\"),
      \\":parent\\": $util.dynamodb.toDynamoDBJson($ctx.args.processAreaId)
    },
    \\"expression\\": \\"#type = :type and #parent = :parent\\"
  },
  #if( $context.args.name )
    \\"filter\\": {
      \\"expression\\" : \\"#name = :name\\",
      \\"expressionNames\\" : {
          \\"#name\\" : \\"name\\"
      },
      \\"expressionValues\\" : {
          \\":name\\" : { \\"S\\" : \\"$ctx.args.name\\" }
      }
    },
  #end
  \\"index\\": \\"ByTypeAndParent-index\\",
  #if ($ctx.args.nextToken)
    \\"nextToken\\": \\"$ctx.args.nextToken\\",
  #end
  \\"limit\\": $util.defaultIfNull($ctx.args.limit, 20)
}
",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceListRootCausesByNameFunctionFunction050B810E": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Get root causes",
        "FunctionVersion": "2018-05-29",
        "Name": "ListRootCausesByNameFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"index\\": \\"ByTypeAndName-index\\",
  \\"query\\": {
    \\"expression\\": \\"#type = :type and #name = :name\\",
    \\"expressionNames\\": {
      \\"#type\\": \\"type\\",
      \\"#name\\": \\"name\\"
    },
    \\"expressionValues\\": {
      \\":type\\": $util.dynamodb.toDynamoDBJson(\\"ROOT_CAUSE\\"),
      \\":name\\": $util.dynamodb.toDynamoDBJson($ctx.args.name)
    }
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceListSitesByNameFunctionFunction5D5DFF68": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Get sites by name",
        "FunctionVersion": "2018-05-29",
        "Name": "ListSitesByNameFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"index\\": \\"ByTypeAndName-index\\",
  \\"limit\\": $util.defaultIfNull($ctx.args.limit, 50),
  #if( $ctx.args.nextToken )
    \\"nextToken\\": \\"$ctx.args.nextToken\\",
  #end
  \\"query\\": {
    \\"expression\\": \\"#type = :type AND #name = :name\\",
    \\"expressionNames\\": {
      \\"#type\\": \\"type\\",
      \\"#name\\": \\"name\\"
    },
    \\"expressionValues\\": {
      \\":type\\": $util.dynamodb.toDynamoDBJson(\\"SITE\\"),
      \\":name\\": $util.dynamodb.toDynamoDBJson($ctx.args.name)
    }
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceListSitesFunctionFunction36AD4955": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Get sites",
        "FunctionVersion": "2018-05-29",
        "Name": "ListSitesFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"index\\": \\"ByTypeAndName-index\\",
  \\"limit\\": $util.defaultIfNull($ctx.args.limit, 50),
  #if( $ctx.args.nextToken )
    \\"nextToken\\": \\"$ctx.args.nextToken\\",
  #end
  \\"query\\": {
    \\"expression\\": \\"#type = :type\\",
    \\"expressionNames\\": {
      \\"#type\\": \\"type\\"
    },
    \\"expressionValues\\": {
      \\":type\\": $util.dynamodb.toDynamoDBJson(\\"SITE\\")
    }
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceListStationsFunctionFunctionEAA3A1EC": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Get stations",
        "FunctionVersion": "2018-05-29",
        "Name": "ListStationsFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"query\\": {
    \\"expressionNames\\": {
      \\"#type\\": \\"type\\",
      \\"#parent\\": \\"parentId\\"
    },
    \\"expressionValues\\": {
      \\":type\\": $util.dynamodb.toDynamoDBJson(\\"STATION\\"),
      \\":parent\\": $util.dynamodb.toDynamoDBJson($ctx.args.stationAreaId)
    },
    \\"expression\\": \\"#type = :type and #parent = :parent\\"
  },
  #if( $context.args.name )
    \\"filter\\": {
      \\"expression\\" : \\"#name = :name\\",
      \\"expressionNames\\" : {
          \\"#name\\" : \\"name\\"
      },
      \\"expressionValues\\" : {
          \\":name\\" : { \\"S\\" : \\"$ctx.args.name\\" }
      }
    },
  #end
  \\"index\\": \\"ByTypeAndParent-index\\",
  #if ($ctx.args.nextToken)
    \\"nextToken\\": \\"$ctx.args.nextToken\\",
  #end
  \\"limit\\": $util.defaultIfNull($ctx.args.limit, 20)
}
",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceMutationdeleteAreaResolver541849F0": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "deleteArea",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"DeleteItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
    \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type)
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceMutationdeleteDeviceResolver027A70E9": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "deleteDevice",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"DeleteItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
    \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type)
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceMutationdeletePermissionResolver255F6CF9": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "deletePermission",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"DeleteItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
    \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type)
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceMutationdeleteProcessResolver9BEA7AA2": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "deleteProcess",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"DeleteItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
    \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type)
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceMutationdeleteRootCauseResolver3B07C493": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "deleteRootCause",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"DeleteItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
    \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type)
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceMutationdeleteSiteResolver3ADFA025": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "deleteSite",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"DeleteItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
    \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type)
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceMutationdeleteStationResolver0920EF47": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "deleteStation",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"DeleteItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
    \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type)
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceMutationputPermissionResolver835B6A05": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "putPermission",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## Set parentId
$util.qr($context.args.input.put(\\"parentId\\", \\"NONE\\"))

## Set updatedAt
$util.qr($context.args.input.put(\\"updatedAt\\", $util.defaultIfNull($ctx.args.input.updatedAt, $util.time.nowISO8601())))

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"PutItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.input.id),
    \\"type\\": $util.dynamodb.toDynamoDBJson(\\"PERMISSION\\")
  },
  \\"attributeValues\\": $util.dynamodb.toMapValuesJson($ctx.args.input)
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceProcessareaResolver33222880": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "area",
        "Kind": "UNIT",
        "RequestMappingTemplate": "{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
      \\"id\\": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.source.processAreaId, \\"___xamznone____\\")),
      \\"type\\": $util.dynamodb.toDynamoDBJson(\\"AREA\\")
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Process",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceProcesseventResolverE43CA050": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "event",
        "Kind": "UNIT",
        "RequestMappingTemplate": "#set( $limit = $util.defaultIfNull($context.args.limit, 10) )
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"query\\": {
    \\"expressionNames\\": {
      \\"#type\\": \\"type\\",
      \\"#parent\\": \\"parentId\\"
    },
    \\"expressionValues\\": {
      \\":type\\": $util.dynamodb.toDynamoDBJson(\\"EVENT\\"),
      \\":parent\\": $util.dynamodb.toDynamoDBJson($ctx.source.id)
    },
    \\"expression\\": \\"#type = :type and #parent = :parent\\"
  },
  \\"scanIndexForward\\":   #if( $context.args.sortDirection )
    #if( $context.args.sortDirection == \\"ASC\\" )
true
    #else
false
    #end
  #else
true
  #end,
  \\"filter\\":   #if( $context.args.filter )
$util.transform.toDynamoDBFilterExpression($ctx.args.filter)
  #else
null
  #end,
  \\"limit\\": $limit,
  \\"nextToken\\":   #if( $context.args.nextToken )
\\"$context.args.nextToken\\"
  #else
null
  #end,
  \\"index\\": \\"ByTypeAndParent-index\\"
}
",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Process",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceQuerygetAreaResolverAEBEFFA4": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "getArea",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])

## If the request is to get a site, an area, a station, or a process, only AdminGroup can access the data.
## The other case would be getting a user permission by every group users.
#if ($ctx.args.id)
  ## For 'getEvent' and 'getPermission', do not restrict to only the AdminGroup
  #if ($ctx.info.fieldName != \\"getEvent\\" && $ctx.info.fieldName != \\"getPermission\\")
    #set ($allowedGroups = [\\"AdminGroup\\"])
  #end
#end

#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## If it needs to get permission, and the user is only in AssociateGroup, get permission.
#if ($ctx.stash.permissionCheck)
  #if ($userGroups.size() == 1 && $userGroups.contains(\\"AssociateGroup\\"))
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
    \\"id\\": { \\"S\\": \\"$ctx.identity.sub\\" },
    \\"type\\": $util.dynamodb.toDynamoDBJson(\\"PERMISSION\\")
  }
}
  #else
    #return({})
  #end
#else
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
  \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
  \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type)
  }
}
#end",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceQuerygetEventResolverC3A56181": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "getEvent",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])

## If the request is to get a site, an area, a station, or a process, only AdminGroup can access the data.
## The other case would be getting a user permission by every group users.
#if ($ctx.args.id)
  ## For 'getEvent' and 'getPermission', do not restrict to only the AdminGroup
  #if ($ctx.info.fieldName != \\"getEvent\\" && $ctx.info.fieldName != \\"getPermission\\")
    #set ($allowedGroups = [\\"AdminGroup\\"])
  #end
#end

#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## If it needs to get permission, and the user is only in AssociateGroup, get permission.
#if ($ctx.stash.permissionCheck)
  #if ($userGroups.size() == 1 && $userGroups.contains(\\"AssociateGroup\\"))
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
    \\"id\\": { \\"S\\": \\"$ctx.identity.sub\\" },
    \\"type\\": $util.dynamodb.toDynamoDBJson(\\"PERMISSION\\")
  }
}
  #else
    #return({})
  #end
#else
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
  \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
  \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type)
  }
}
#end",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceQuerygetPermissionResolverC9DC9032": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "getPermission",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])

## If the request is to get a site, an area, a station, or a process, only AdminGroup can access the data.
## The other case would be getting a user permission by every group users.
#if ($ctx.args.id)
  ## For 'getEvent' and 'getPermission', do not restrict to only the AdminGroup
  #if ($ctx.info.fieldName != \\"getEvent\\" && $ctx.info.fieldName != \\"getPermission\\")
    #set ($allowedGroups = [\\"AdminGroup\\"])
  #end
#end

#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## If it needs to get permission, and the user is only in AssociateGroup, get permission.
#if ($ctx.stash.permissionCheck)
  #if ($userGroups.size() == 1 && $userGroups.contains(\\"AssociateGroup\\"))
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
    \\"id\\": { \\"S\\": \\"$ctx.identity.sub\\" },
    \\"type\\": $util.dynamodb.toDynamoDBJson(\\"PERMISSION\\")
  }
}
  #else
    #return({})
  #end
#else
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
  \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
  \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type)
  }
}
#end",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceQuerygetProcessResolver2A3DAC30": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "getProcess",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])

## If the request is to get a site, an area, a station, or a process, only AdminGroup can access the data.
## The other case would be getting a user permission by every group users.
#if ($ctx.args.id)
  ## For 'getEvent' and 'getPermission', do not restrict to only the AdminGroup
  #if ($ctx.info.fieldName != \\"getEvent\\" && $ctx.info.fieldName != \\"getPermission\\")
    #set ($allowedGroups = [\\"AdminGroup\\"])
  #end
#end

#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## If it needs to get permission, and the user is only in AssociateGroup, get permission.
#if ($ctx.stash.permissionCheck)
  #if ($userGroups.size() == 1 && $userGroups.contains(\\"AssociateGroup\\"))
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
    \\"id\\": { \\"S\\": \\"$ctx.identity.sub\\" },
    \\"type\\": $util.dynamodb.toDynamoDBJson(\\"PERMISSION\\")
  }
}
  #else
    #return({})
  #end
#else
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
  \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
  \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type)
  }
}
#end",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceQuerygetSiteResolver13779358": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "getSite",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])

## If the request is to get a site, an area, a station, or a process, only AdminGroup can access the data.
## The other case would be getting a user permission by every group users.
#if ($ctx.args.id)
  ## For 'getEvent' and 'getPermission', do not restrict to only the AdminGroup
  #if ($ctx.info.fieldName != \\"getEvent\\" && $ctx.info.fieldName != \\"getPermission\\")
    #set ($allowedGroups = [\\"AdminGroup\\"])
  #end
#end

#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## If it needs to get permission, and the user is only in AssociateGroup, get permission.
#if ($ctx.stash.permissionCheck)
  #if ($userGroups.size() == 1 && $userGroups.contains(\\"AssociateGroup\\"))
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
    \\"id\\": { \\"S\\": \\"$ctx.identity.sub\\" },
    \\"type\\": $util.dynamodb.toDynamoDBJson(\\"PERMISSION\\")
  }
}
  #else
    #return({})
  #end
#else
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
  \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
  \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type)
  }
}
#end",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceQuerygetStationResolver5092B7D7": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "getStation",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])

## If the request is to get a site, an area, a station, or a process, only AdminGroup can access the data.
## The other case would be getting a user permission by every group users.
#if ($ctx.args.id)
  ## For 'getEvent' and 'getPermission', do not restrict to only the AdminGroup
  #if ($ctx.info.fieldName != \\"getEvent\\" && $ctx.info.fieldName != \\"getPermission\\")
    #set ($allowedGroups = [\\"AdminGroup\\"])
  #end
#end

#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## If it needs to get permission, and the user is only in AssociateGroup, get permission.
#if ($ctx.stash.permissionCheck)
  #if ($userGroups.size() == 1 && $userGroups.contains(\\"AssociateGroup\\"))
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
    \\"id\\": { \\"S\\": \\"$ctx.identity.sub\\" },
    \\"type\\": $util.dynamodb.toDynamoDBJson(\\"PERMISSION\\")
  }
}
  #else
    #return({})
  #end
#else
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
  \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
  \\"type\\": $util.dynamodb.toDynamoDBJson($ctx.args.type)
  }
}
#end",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceQuerylistPermissionsResolver6647FB7C": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "listPermissions",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"index\\": \\"ByTypeAndParent-index\\",
  \\"limit\\": $util.defaultIfNull($ctx.args.limit, 50),
  #if( $ctx.args.nextToken )
    \\"nextToken\\": \\"$ctx.args.nextToken\\",
  #end
  \\"query\\": {
    \\"expression\\": \\"#type = :type and #parent = :parent\\",
    \\"expressionNames\\": {
      \\"#type\\": \\"type\\",
      \\"#parent\\": \\"parentId\\"
    },
    \\"expressionValues\\": {
      \\":type\\": $util.dynamodb.toDynamoDBJson(\\"PERMISSION\\"),
      \\":parent\\": $util.dynamodb.toDynamoDBJson(\\"NONE\\")
    }
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceQuerylistRootCausesResolver2D68522F": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "listRootCauses",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"index\\": \\"ByTypeAndName-index\\",
  \\"limit\\": $util.defaultIfNull($ctx.args.limit, 50),
  #if( $ctx.args.nextToken )
    \\"nextToken\\": \\"$ctx.args.nextToken\\",
  #end
  \\"query\\": {
    \\"expression\\": \\"#type = :type\\",
    \\"expressionNames\\": {
      \\"#type\\": \\"type\\"
    },
    \\"expressionValues\\": {
      \\":type\\": $util.dynamodb.toDynamoDBJson(\\"ROOT_CAUSE\\")
    }
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceServiceRole91F4DE80": Object {
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "Service": "appsync.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceServiceRoleDefaultPolicyE43B8B38": Object {
      "Properties": Object {
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": Array [
                "dynamodb:BatchGetItem",
                "dynamodb:GetRecords",
                "dynamodb:GetShardIterator",
                "dynamodb:Query",
                "dynamodb:GetItem",
                "dynamodb:Scan",
                "dynamodb:ConditionCheckItem",
                "dynamodb:BatchWriteItem",
                "dynamodb:PutItem",
                "dynamodb:UpdateItem",
                "dynamodb:DeleteItem",
              ],
              "Effect": "Allow",
              "Resource": Array [
                Object {
                  "Fn::GetAtt": Array [
                    "AVADataHierarchyTable",
                    "Arn",
                  ],
                },
                Object {
                  "Fn::Join": Array [
                    "",
                    Array [
                      Object {
                        "Fn::GetAtt": Array [
                          "AVADataHierarchyTable",
                          "Arn",
                        ],
                      },
                      "/index/*",
                    ],
                  ],
                },
              ],
            },
          ],
          "Version": "2012-10-17",
        },
        "PolicyName": "BackEndAppSyncApiGraphqlApiAVADataSourceServiceRoleDefaultPolicyE43B8B38",
        "Roles": Array [
          Object {
            "Ref": "BackEndAppSyncApiGraphqlApiAVADataSourceServiceRole91F4DE80",
          },
        ],
      },
      "Type": "AWS::IAM::Policy",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceSiteareaResolver283D36FD": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "area",
        "Kind": "UNIT",
        "RequestMappingTemplate": "#set( $limit = $util.defaultIfNull($context.args.limit, 10) )
#set( $query = {
  \\"expression\\": \\"#type = :type and #connectionAttribute = :connectionAttribute\\",
  \\"expressionNames\\": {
      \\"#type\\": \\"type\\",
      \\"#connectionAttribute\\": \\"parentId\\"
  },
  \\"expressionValues\\": {
      \\":type\\": { \\"S\\": \\"AREA\\" },
      \\":connectionAttribute\\": {
          \\"S\\": \\"$context.source.id\\"
    }
  }
} )
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"query\\":   $util.toJson($query),
  \\"scanIndexForward\\":   #if( $context.args.sortDirection )
    #if( $context.args.sortDirection == \\"ASC\\" )
true
    #else
false
    #end
  #else
true
  #end,
  \\"filter\\":   #if( $context.args.filter )
$util.transform.toDynamoDBFilterExpression($ctx.args.filter)
  #else
null
  #end,
  \\"limit\\": $limit,
  \\"nextToken\\":   #if( $context.args.nextToken )
\\"$context.args.nextToken\\"
  #else
null
  #end,
  \\"index\\": \\"ByTypeAndParent-index\\"
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Site",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceStationareaResolverC5D08A07": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "area",
        "Kind": "UNIT",
        "RequestMappingTemplate": "{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"GetItem\\",
  \\"key\\": {
      \\"id\\": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.source.stationAreaId, \\"___xamznone____\\")),
      \\"type\\": $util.dynamodb.toDynamoDBJson(\\"AREA\\")
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Station",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceStationdeviceResolverF56BD6E9": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "FieldName": "device",
        "Kind": "UNIT",
        "RequestMappingTemplate": "#set( $limit = $util.defaultIfNull($context.args.limit, 10) )
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"query\\": {
    \\"expression\\": \\"#type = :type and #parent = :parent\\",
    \\"expressionNames\\": {
      \\"#type\\": \\"type\\",
      \\"#parent\\": \\"parentId\\"
    },
    \\"expressionValues\\": {
      \\":type\\": { \\"S\\": \\"DEVICE\\" },
      \\":parent\\": { \\"S\\": \\"$context.source.id\\" }
    }
  },
  \\"scanIndexForward\\":   #if( $context.args.sortDirection )
    #if( $context.args.sortDirection == \\"ASC\\" )
true
    #else
false
    #end
  #else
true
  #end,
  \\"filter\\":   #if( $context.args.filter )
$util.transform.toDynamoDBFilterExpression($ctx.args.filter)
  #else
null
  #end,
  \\"limit\\": $limit,
  \\"nextToken\\":   #if( $context.args.nextToken )
\\"$context.args.nextToken\\"
  #else
null
  #end,
  \\"index\\": \\"ByTypeAndParent-index\\"
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Station",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVADataSourceUpdateEventFunctionFunction5CE7A71C": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVADataSource4AA6D608",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVADataSource",
        "Description": "Update an event",
        "FunctionVersion": "2018-05-29",
        "Name": "UpdateEventFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

#set ($update = {})

## Check validation
#if ($ctx.args.sms and $ctx.args.sms != \\"\\")
  #if (!$util.matches(\\"^((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4})(,\\\\s*((\\\\+\\\\d{1,2}\\\\s)?\\\\(?\\\\d{3}\\\\)?[\\\\s.-]?\\\\d{3}[\\\\s.-]?\\\\d{4}))*$\\", $ctx.args.sms))
    $util.error(\\"SMS No. must be a comma-separated list of valid phone numbers.\\")
  #end
#end
#if ($ctx.args.email and $ctx.args.email != \\"\\")
  #if (!$util.matches(\\"^([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+)(,\\\\s*([_a-z0-9-]+(\\\\.[_a-z0-9-]+)*(\\\\+[a-z0-9-]+)?@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+))*$\\", $ctx.args.email))
    $util.error(\\"E-Mail must be a comma-separated list of valid E-Mail addresses.\\")
  #end
#end

## Set updatedAt
#set ($updatedAt = $util.defaultIfNull($ctx.args.updatedAt, $util.time.nowISO8601()))
#set ($expression = \\"SET\\")
#set ($expressionValues = {})

## Set expression and expressionValues
#if ($ctx.args.sms)
  #set ($expression = \\"$expression sms = :sms,\\")
  $util.qr($expressionValues.put(\\":sms\\", $util.dynamodb.toDynamoDB($ctx.args.sms)))
#end
#if ($ctx.args.email)
  #set ($expression = \\"$expression email = :email,\\")
  $util.qr($expressionValues.put(\\":email\\", $util.dynamodb.toDynamoDB($ctx.args.email)))
#end
#if ($ctx.args.rootCauses)
  #set ($expression = \\"$expression rootCauses = :rootCauses,\\")
  $util.qr($expressionValues.put(\\":rootCauses\\", $util.dynamodb.toDynamoDB($ctx.args.rootCauses)))
#end
#if ($ctx.args.eventImgKey)
  #set ($expression = \\"$expression eventImgKey = :eventImgKey,\\")
  $util.qr($expressionValues.put(\\":eventImgKey\\", $util.dynamodb.toDynamoDB($ctx.args.eventImgKey)))
#end
#if ($ctx.args.alias)
  #set ($expression = \\"$expression alias = :alias,\\")
  $util.qr($expressionValues.put(\\":alias\\", $util.dynamodb.toDynamoDB($ctx.args.alias)))
#end

$util.qr($expressionValues.put(\\":version\\", $util.dynamodb.toDynamoDB($util.defaultIfNull($ctx.args.version, 1))))
$util.qr($expressionValues.put(\\":updatedAt\\", $util.dynamodb.toDynamoDB($updatedAt)))

{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": {
    \\"id\\": $util.dynamodb.toDynamoDBJson($ctx.args.id),
    \\"type\\": $util.dynamodb.toDynamoDBJson(\\"EVENT\\")
  },
  \\"update\\": {
    \\"expression\\": \\"$expression version = :version, updatedAt = :updatedAt\\",
    \\"expressionValues\\": $util.toJson($expressionValues)
  }
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVALambdaDataSource3AD4F63E": Object {
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "LambdaConfig": Object {
          "LambdaFunctionArn": Object {
            "Fn::GetAtt": Array [
              "BackEndAppSyncApiAppSyncResolverLambdaFunctionE084D1FB",
              "Arn",
            ],
          },
        },
        "Name": "AVALambdaDataSource",
        "ServiceRoleArn": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApiAVALambdaDataSourceServiceRoleD6FEB4B3",
            "Arn",
          ],
        },
        "Type": "AWS_LAMBDA",
      },
      "Type": "AWS::AppSync::DataSource",
    },
    "BackEndAppSyncApiGraphqlApiAVALambdaDataSourceHandleEventSnsFunctionFunction6CECC98A": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVALambdaDataSource3AD4F63E",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVALambdaDataSource",
        "Description": "Manages SNS Subscriptions to the main AVA Topic",
        "FunctionVersion": "2018-05-29",
        "Name": "HandleEventSnsFunction",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiAVALambdaDataSourceQuerygetPrevDayIssuesStatsResolver82E65C13": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiAVALambdaDataSource3AD4F63E",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "AVALambdaDataSource",
        "FieldName": "getPrevDayIssuesStats",
        "Kind": "UNIT",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiAVALambdaDataSourceServiceRoleD6FEB4B3": Object {
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "Service": "appsync.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "BackEndAppSyncApiGraphqlApiAVALambdaDataSourceServiceRoleDefaultPolicy2DB725F0": Object {
      "Properties": Object {
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "lambda:InvokeFunction",
              "Effect": "Allow",
              "Resource": Object {
                "Fn::GetAtt": Array [
                  "BackEndAppSyncApiAppSyncResolverLambdaFunctionE084D1FB",
                  "Arn",
                ],
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "PolicyName": "BackEndAppSyncApiGraphqlApiAVALambdaDataSourceServiceRoleDefaultPolicy2DB725F0",
        "Roles": Array [
          Object {
            "Ref": "BackEndAppSyncApiGraphqlApiAVALambdaDataSourceServiceRoleD6FEB4B3",
          },
        ],
      },
      "Type": "AWS::IAM::Policy",
    },
    "BackEndAppSyncApiGraphqlApiIssueDataSourceFCF50787": Object {
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DynamoDBConfig": Object {
          "AwsRegion": Object {
            "Ref": "AWS::Region",
          },
          "TableName": Object {
            "Ref": "AVAIssuesTable",
          },
        },
        "Name": "IssueDataSource",
        "ServiceRoleArn": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApiIssueDataSourceServiceRole7CFC1804",
            "Arn",
          ],
        },
        "Type": "AMAZON_DYNAMODB",
      },
      "Type": "AWS::AppSync::DataSource",
    },
    "BackEndAppSyncApiGraphqlApiIssueDataSourceListIssuesByDeviceFunctionFunction988D9D87": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiIssueDataSourceFCF50787",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "IssueDataSource",
        "Description": "Get issues by device",
        "FunctionVersion": "2018-05-29",
        "Name": "ListIssuesByDeviceFunction",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## [Start] Set query expression for @key **
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated) && $util.isNullOrBlank($ctx.args.siteName) )
  $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated' you must also provide 'siteName'.\\", \\"InvalidArgumentsError\\")
#end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated) )
  #set( $sortKeyArgumentOperations = $ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.keySet() )
  #if( $sortKeyArgumentOperations.size() > 1 )
    $util.error(\\"Argument areaNameStatusProcessNameStationNameDeviceNameCreated must specify at most one key condition operation.\\", \\"InvalidArgumentsError\\")
  #end
  #foreach( $operation in $sortKeyArgumentOperations )
    #if( $operation == \\"between\\" )
      #if( $ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between.size() != 2 )
        $util.error(\\"Argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.between' expects exactly two elements.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].created) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].deviceName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].created' you must also provide 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].deviceName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].created) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].deviceName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].created' you must also provide 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].deviceName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].deviceName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].stationName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].deviceName' you must also provide 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].stationName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].deviceName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].stationName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].deviceName' you must also provide 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].stationName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].stationName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].processName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].stationName' you must also provide 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].processName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].stationName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].processName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].stationName' you must also provide 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].processName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].processName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].status) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].processName' you must also provide 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].status'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].processName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].status) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].processName' you must also provide 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].status'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].status) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].areaName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].status' you must also provide 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].areaName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].status) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].areaName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].status' you must also provide 'areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].areaName'.\\", \\"InvalidArgumentsError\\")
      #end
    #else
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.get(\\"$operation\\").created) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.get(\\"$operation\\").deviceName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.$operation.created' you must also provide 'areaNameStatusProcessNameStationNameDeviceNameCreated.$operation.deviceName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.get(\\"$operation\\").deviceName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.get(\\"$operation\\").stationName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.$operation.deviceName' you must also provide 'areaNameStatusProcessNameStationNameDeviceNameCreated.$operation.stationName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.get(\\"$operation\\").stationName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.get(\\"$operation\\").processName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.$operation.stationName' you must also provide 'areaNameStatusProcessNameStationNameDeviceNameCreated.$operation.processName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.get(\\"$operation\\").processName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.get(\\"$operation\\").status) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.$operation.processName' you must also provide 'areaNameStatusProcessNameStationNameDeviceNameCreated.$operation.status'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.get(\\"$operation\\").status) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.get(\\"$operation\\").areaName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameStationNameDeviceNameCreated.$operation.status' you must also provide 'areaNameStatusProcessNameStationNameDeviceNameCreated.$operation.areaName'.\\", \\"InvalidArgumentsError\\")
      #end
    #end
  #end
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.siteName) )
  #set( $modelQueryExpression.expression = \\"#siteName = :siteName\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#siteName\\": \\"siteName\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":siteName\\": {
      \\"S\\": \\"$ctx.args.siteName\\"
  }
} )
#end
## [Start] Applying Key Condition **
#set( $sortKeyValue = \\"\\" )
#set( $sortKeyValue2 = \\"\\" )
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated) && !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.beginsWith) )
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.beginsWith.areaName) ) #set( $sortKeyValue = \\"$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.beginsWith.areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.beginsWith.status) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.beginsWith.status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.beginsWith.processName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.beginsWith.processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.beginsWith.stationName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.beginsWith.stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.beginsWith.deviceName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.beginsWith.deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.beginsWith.created) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.beginsWith.created\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"areaName#status#processName#stationName#deviceName#created\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated) && !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between) )
  #if( $ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between.size() != 2 )
    $util.error(\\"Argument areaNameStatusProcessNameStationNameDeviceNameCreated.between expects exactly 2 elements.\\")
  #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].areaName) ) #set( $sortKeyValue = \\"$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].status) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].processName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].stationName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].deviceName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].created) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[0].created\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].areaName) ) #set( $sortKeyValue2 = \\"$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].status) ) #set( $sortKeyValue2 = \\"$sortKeyValue2#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].processName) ) #set( $sortKeyValue2 = \\"$sortKeyValue2#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].stationName) ) #set( $sortKeyValue2 = \\"$sortKeyValue2#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].deviceName) ) #set( $sortKeyValue2 = \\"$sortKeyValue2#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].created) ) #set( $sortKeyValue2 = \\"$sortKeyValue2#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.between[1].created\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"areaName#status#processName#stationName#deviceName#created\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$sortKeyValue\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$sortKeyValue2\\" }))
#end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated) && !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.eq) )
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.eq.areaName) ) #set( $sortKeyValue = \\"$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.eq.areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.eq.status) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.eq.status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.eq.processName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.eq.processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.eq.stationName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.eq.stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.eq.deviceName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.eq.deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.eq.created) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.eq.created\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"areaName#status#processName#stationName#deviceName#created\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated) && !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.lt) )
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.lt.areaName) ) #set( $sortKeyValue = \\"$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.lt.areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.lt.status) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.lt.status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.lt.processName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.lt.processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.lt.stationName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.lt.stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.lt.deviceName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.lt.deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.lt.created) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.lt.created\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"areaName#status#processName#stationName#deviceName#created\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated) && !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.le) )
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.le.areaName) ) #set( $sortKeyValue = \\"$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.le.areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.le.status) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.le.status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.le.processName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.le.processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.le.stationName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.le.stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.le.deviceName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.le.deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.le.created) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.le.created\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"areaName#status#processName#stationName#deviceName#created\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated) && !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.gt) )
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.gt.areaName) ) #set( $sortKeyValue = \\"$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.gt.areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.gt.status) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.gt.status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.gt.processName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.gt.processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.gt.stationName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.gt.stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.gt.deviceName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.gt.deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.gt.created) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.gt.created\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"areaName#status#processName#stationName#deviceName#created\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated) && !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.ge) )
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.ge.areaName) ) #set( $sortKeyValue = \\"$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.ge.areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.ge.status) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.ge.status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.ge.processName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.ge.processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.ge.stationName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.ge.stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.ge.deviceName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.ge.deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.ge.created) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameStationNameDeviceNameCreated.ge.created\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"areaName#status#processName#stationName#deviceName#created\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end


## [End] Applying Key Condition **
## [End] Set query expression for @key **
#set( $limit = $util.defaultIfNull($context.args.limit, 10) )
#set( $QueryRequest = {
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"limit\\": $limit,
  \\"query\\": $modelQueryExpression,
  \\"index\\": \\"ByDevice-index\\"
} )
#if( !$util.isNull($ctx.args.sortDirection)
                    && $ctx.args.sortDirection == \\"DESC\\" )
  #set( $QueryRequest.scanIndexForward = false )
#else
  #set( $QueryRequest.scanIndexForward = true )
#end
#if( $context.args.nextToken ) #set( $QueryRequest.nextToken = \\"$context.args.nextToken\\" ) #end
#if( $context.args.filter ) #set( $QueryRequest.filter = $util.parseJson(\\"$util.transform.toDynamoDBFilterExpression($ctx.args.filter)\\") ) #end
$util.toJson($QueryRequest)",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
      },
      "Type": "AWS::AppSync::FunctionConfiguration",
    },
    "BackEndAppSyncApiGraphqlApiIssueDataSourceMutationcreateIssueResolver25AB5433": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiIssueDataSourceFCF50787",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "IssueDataSource",
        "FieldName": "createIssue",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## [Start] Determine request authentication mode **
#if( $util.isNullOrEmpty($authMode) && !$util.isNull($ctx.identity) && !$util.isNull($ctx.identity.sub) && !$util.isNull($ctx.identity.issuer) && !$util.isNull($ctx.identity.username) && !$util.isNull($ctx.identity.claims) && !$util.isNull($ctx.identity.sourceIp) && !$util.isNull($ctx.identity.defaultAuthStrategy) )
  #set( $authMode = \\"userPools\\" )
#end
## [End] Determine request authentication mode **
## [Start] Check authMode and execute owner/group checks **
#if( $authMode == \\"userPools\\" )
  ## [Start] Static Group Authorization Checks **
  #set($isStaticGroupAuthorized = $util.defaultIfNull(
            $isStaticGroupAuthorized, false))
  ## Authorization rule: { allow: groups, groups: [\\"AdminGroup\\"], groupClaim: \\"cognito:groups\\" } **
  #set( $userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []) )
  #set( $allowedGroups = [\\"AdminGroup\\"] )
  #foreach( $userGroup in $userGroups )
    #if( $allowedGroups.contains($userGroup) )
      #set( $isStaticGroupAuthorized = true )
      #break
    #end
  #end
  ## Authorization rule: { allow: groups, groups: [\\"ManagerGroup\\"], groupClaim: \\"cognito:groups\\" } **
  #set( $userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []) )
  #set( $allowedGroups = [\\"ManagerGroup\\"] )
  #foreach( $userGroup in $userGroups )
    #if( $allowedGroups.contains($userGroup) )
      #set( $isStaticGroupAuthorized = true )
      #break
    #end
  #end
  ## Authorization rule: { allow: groups, groups: [\\"AssociateGroup\\"], groupClaim: \\"cognito:groups\\" } **
  #set( $userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []) )
  #set( $allowedGroups = [\\"AssociateGroup\\"] )
  #foreach( $userGroup in $userGroups )
    #if( $allowedGroups.contains($userGroup) )
      #set( $isStaticGroupAuthorized = true )
      #break
    #end
  #end
  ## Authorization rule: { allow: groups, groups: [\\"EngineerGroup\\"], groupClaim: \\"cognito:groups\\" } **
  #set( $userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []) )
  #set( $allowedGroups = [\\"EngineerGroup\\"] )
  #foreach( $userGroup in $userGroups )
    #if( $allowedGroups.contains($userGroup) )
      #set( $isStaticGroupAuthorized = true )
      #break
    #end
  #end
  ## [End] Static Group Authorization Checks **


  ## No Dynamic Group Authorization Rules **


  ## No Owner Authorization Rules **


  ## [Start] Throw if unauthorized **
  #if( !($isStaticGroupAuthorized == true || $isDynamicGroupAuthorized == true || $isOwnerAuthorized == true) )
    $util.unauthorized()
  #end
  ## [End] Throw if unauthorized **
#end
## [End] Check authMode and execute owner/group checks **

#if( $util.isNull($dynamodbNameOverrideMap) )
  #set( $dynamodbNameOverrideMap = {
  \\"areaName#status#processName#stationName#deviceName#created\\": \\"areaNameStatusProcessNameStationNameDeviceNameCreated\\"
} )
#else
  $util.qr($dynamodbNameOverrideMap.put(\\"areaName#status#processName#stationName#deviceName#created\\", \\"areaNameStatusProcessNameStationNameDeviceNameCreated\\"))
#end
$util.qr($ctx.args.input.put(\\"areaName#status#processName#stationName#deviceName#created\\",\\"\${ctx.args.input.areaName}#\${ctx.args.input.status}#\${ctx.args.input.processName}#\${ctx.args.input.stationName}#\${ctx.args.input.deviceName}#\${ctx.args.input.created}\\"))
#if( $util.isNull($dynamodbNameOverrideMap) )
  #set( $dynamodbNameOverrideMap = {
  \\"areaName#status#processName#eventDescription#stationName#deviceName#created\\": \\"areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated\\"
} )
#else
  $util.qr($dynamodbNameOverrideMap.put(\\"areaName#status#processName#eventDescription#stationName#deviceName#created\\", \\"areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated\\"))
#end
$util.qr($ctx.args.input.put(\\"areaName#status#processName#eventDescription#stationName#deviceName#created\\",\\"\${ctx.args.input.areaName}#\${ctx.args.input.status}#\${ctx.args.input.processName}#\${ctx.args.input.eventDescription}#\${ctx.args.input.stationName}#\${ctx.args.input.deviceName}#\${ctx.args.input.created}\\"))

## [Start] Set the primary @key. **
#set( $modelObjectKey = {
  \\"id\\": $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
## [End] Set the primary @key. **

## [Start] Setting \\"version\\" to 1. **
$util.qr($ctx.args.input.put(\\"version\\", 1))
## [End] Setting \\"version\\" to 1. **

## [Start] Prepare DynamoDB PutItem Request. **
$util.qr($context.args.input.put(\\"createdDateUtc\\", $util.defaultIfNull($ctx.args.createdDateUtc, $util.time.nowFormatted(\\"yyyy-MM-dd\\", \\"+00:00\\"))))
$util.qr($context.args.input.put(\\"createdAt\\", $util.defaultIfNull($ctx.args.input.createdAt, $util.time.nowISO8601())))
$util.qr($context.args.input.put(\\"updatedAt\\", $util.defaultIfNull($ctx.args.input.updatedAt, $util.time.nowISO8601())))
$util.qr($context.args.input.put(\\"deviceName#eventId\\", \\"\${ctx.args.input.deviceName}#\${ctx.args.input.eventId}\\"))
#set( $condition = {
  \\"expression\\": \\"attribute_not_exists(#id)\\",
  \\"expressionNames\\": {
      \\"#id\\": \\"id\\"
  }
} )
#if( $context.args.condition )
  #set( $condition.expressionValues = {} )
  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $conditionFilterExpressions.expression\\"))
  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
#end
#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
  #set( $condition = {
  \\"expression\\": $condition.expression,
  \\"expressionNames\\": $condition.expressionNames
} )
#end
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"PutItem\\",
  \\"key\\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
  \\"id\\":   $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.input.id, $util.autoId()))
} #end,
  \\"attributeValues\\": $util.dynamodb.toMapValuesJson($context.args.input),
  \\"condition\\": $util.toJson($condition)
}
## [End] Prepare DynamoDB PutItem Request. **",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiIssueDataSourceMutationupdateIssueResolver68669AD5": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiIssueDataSourceFCF50787",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "IssueDataSource",
        "FieldName": "updateIssue",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## [Start] Determine request authentication mode **
#if( $util.isNullOrEmpty($authMode) && !$util.isNull($ctx.identity) && !$util.isNull($ctx.identity.sub) && !$util.isNull($ctx.identity.issuer) && !$util.isNull($ctx.identity.username) && !$util.isNull($ctx.identity.claims) && !$util.isNull($ctx.identity.sourceIp) && !$util.isNull($ctx.identity.defaultAuthStrategy) )
  #set( $authMode = \\"userPools\\" )
#end
## [End] Determine request authentication mode **
## [Start] Check authMode and execute owner/group checks **
#if( $authMode == \\"userPools\\" )
  ## [Start] Static Group Authorization Checks **
  #set($isStaticGroupAuthorized = $util.defaultIfNull(
            $isStaticGroupAuthorized, false))
  ## Authorization rule: { allow: groups, groups: [\\"AdminGroup\\"], groupClaim: \\"cognito:groups\\" } **
  #set( $userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []) )
  #set( $allowedGroups = [\\"AdminGroup\\"] )
  #foreach( $userGroup in $userGroups )
    #if( $allowedGroups.contains($userGroup) )
      #set( $isStaticGroupAuthorized = true )
      #break
    #end
  #end
  ## Authorization rule: { allow: groups, groups: [\\"ManagerGroup\\"], groupClaim: \\"cognito:groups\\" } **
  #set( $userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []) )
  #set( $allowedGroups = [\\"ManagerGroup\\"] )
  #foreach( $userGroup in $userGroups )
    #if( $allowedGroups.contains($userGroup) )
      #set( $isStaticGroupAuthorized = true )
      #break
    #end
  #end
  ## Authorization rule: { allow: groups, groups: [\\"AssociateGroup\\"], groupClaim: \\"cognito:groups\\" } **
  #set( $userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []) )
  #set( $allowedGroups = [\\"AssociateGroup\\"] )
  #foreach( $userGroup in $userGroups )
    #if( $allowedGroups.contains($userGroup) )
      #set( $isStaticGroupAuthorized = true )
      #break
    #end
  #end
  ## Authorization rule: { allow: groups, groups: [\\"EngineerGroup\\"], groupClaim: \\"cognito:groups\\" } **
  #set( $userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []) )
  #set( $allowedGroups = [\\"EngineerGroup\\"] )
  #foreach( $userGroup in $userGroups )
    #if( $allowedGroups.contains($userGroup) )
      #set( $isStaticGroupAuthorized = true )
      #break
    #end
  #end
  ## [End] Static Group Authorization Checks **


  #if( ! $isStaticGroupAuthorized )
    ## No dynamic group authorization rules **


    ## No owner authorization rules **


    ## [Start] Collect Auth Condition **
    #set( $authCondition = $util.defaultIfNull($authCondition, {
  \\"expression\\": \\"\\",
  \\"expressionNames\\": {},
  \\"expressionValues\\": {}
}) )
    #set( $totalAuthExpression = \\"\\" )
    ## Add dynamic group auth conditions if they exist **
    #if( $groupAuthExpressions )
      #foreach( $authExpr in $groupAuthExpressions )
        #set( $totalAuthExpression = \\"$totalAuthExpression $authExpr\\" )
        #if( $foreach.hasNext )
          #set( $totalAuthExpression = \\"$totalAuthExpression OR\\" )
        #end
      #end
    #end
    #if( $groupAuthExpressionNames )
      $util.qr($authCondition.expressionNames.putAll($groupAuthExpressionNames))
    #end
    #if( $groupAuthExpressionValues )
      $util.qr($authCondition.expressionValues.putAll($groupAuthExpressionValues))
    #end
    ## Add owner auth conditions if they exist **
    #if( $totalAuthExpression != \\"\\" && $ownerAuthExpressions && $ownerAuthExpressions.size() > 0 )
      #set( $totalAuthExpression = \\"$totalAuthExpression OR\\" )
    #end
    #if( $ownerAuthExpressions )
      #foreach( $authExpr in $ownerAuthExpressions )
        #set( $totalAuthExpression = \\"$totalAuthExpression $authExpr\\" )
        #if( $foreach.hasNext )
          #set( $totalAuthExpression = \\"$totalAuthExpression OR\\" )
        #end
      #end
    #end
    #if( $ownerAuthExpressionNames )
      $util.qr($authCondition.expressionNames.putAll($ownerAuthExpressionNames))
    #end
    #if( $ownerAuthExpressionValues )
      $util.qr($authCondition.expressionValues.putAll($ownerAuthExpressionValues))
    #end
    ## Set final expression if it has changed. **
    #if( $totalAuthExpression != \\"\\" )
      #if( $util.isNullOrEmpty($authCondition.expression) )
        #set( $authCondition.expression = \\"($totalAuthExpression)\\" )
      #else
        #set( $authCondition.expression = \\"$authCondition.expression AND ($totalAuthExpression)\\" )
      #end
    #end
    ## [End] Collect Auth Condition **
  #end


  ## [Start] Throw if unauthorized **
  #if( !($isStaticGroupAuthorized == true || ($totalAuthExpression != \\"\\")) )
    $util.unauthorized()
  #end
  ## [End] Throw if unauthorized **
#end
## [End] Check authMode and execute owner/group checks **

## [Start] Validate update mutation for @key 'ByDevice'. **
#set( $hasSeenSomeKeyArg = false )
#set( $keyFieldNames = [\\"areaName\\", \\"status\\", \\"processName\\", \\"stationName\\", \\"deviceName\\", \\"created\\"] )
#foreach( $keyFieldName in $keyFieldNames )
#if( $ctx.args.input.containsKey(\\"$keyFieldName\\") ) #set( $hasSeenSomeKeyArg = true ) #end
#end
#foreach( $keyFieldName in $keyFieldNames )
  #if( $hasSeenSomeKeyArg && !$ctx.args.input.containsKey(\\"$keyFieldName\\") )
    $util.error(\\"When updating any part of the composite sort key for @key 'ByDevice', you must provide all fields for the key. Missing key: '$keyFieldName'.\\")
  #end
#end
## [End] Validate update mutation for @key 'ByDevice'. **
#if( $util.isNull($dynamodbNameOverrideMap) )
  #set( $dynamodbNameOverrideMap = {
  \\"areaName#status#processName#stationName#deviceName#created\\": \\"areaNameStatusProcessNameStationNameDeviceNameCreated\\"
} )
#else
  $util.qr($dynamodbNameOverrideMap.put(\\"areaName#status#processName#stationName#deviceName#created\\", \\"areaNameStatusProcessNameStationNameDeviceNameCreated\\"))
#end
$util.qr($ctx.args.input.put(\\"areaName#status#processName#stationName#deviceName#created\\",\\"\${ctx.args.input.areaName}#\${ctx.args.input.status}#\${ctx.args.input.processName}#\${ctx.args.input.stationName}#\${ctx.args.input.deviceName}#\${ctx.args.input.created}\\"))
## [Start] Validate update mutation for @key 'BySiteAreaStatus'. **
#set( $hasSeenSomeKeyArg = false )
#set( $keyFieldNames = [\\"areaName\\", \\"status\\", \\"processName\\", \\"eventDescription\\", \\"stationName\\", \\"deviceName\\", \\"created\\"] )
#foreach( $keyFieldName in $keyFieldNames )
#if( $ctx.args.input.containsKey(\\"$keyFieldName\\") ) #set( $hasSeenSomeKeyArg = true ) #end
#end
#foreach( $keyFieldName in $keyFieldNames )
  #if( $hasSeenSomeKeyArg && !$ctx.args.input.containsKey(\\"$keyFieldName\\") )
    $util.error(\\"When updating any part of the composite sort key for @key 'BySiteAreaStatus', you must provide all fields for the key. Missing key: '$keyFieldName'.\\")
  #end
#end
## [End] Validate update mutation for @key 'BySiteAreaStatus'. **
#if( $util.isNull($dynamodbNameOverrideMap) )
  #set( $dynamodbNameOverrideMap = {
  \\"areaName#status#processName#eventDescription#stationName#deviceName#created\\": \\"areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated\\"
} )
#else
  $util.qr($dynamodbNameOverrideMap.put(\\"areaName#status#processName#eventDescription#stationName#deviceName#created\\", \\"areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated\\"))
#end
$util.qr($ctx.args.input.put(\\"areaName#status#processName#eventDescription#stationName#deviceName#created\\",\\"\${ctx.args.input.areaName}#\${ctx.args.input.status}#\${ctx.args.input.processName}#\${ctx.args.input.eventDescription}#\${ctx.args.input.stationName}#\${ctx.args.input.deviceName}#\${ctx.args.input.created}\\"))


## [Start] Set the primary @key. **
#set( $modelObjectKey = {
  \\"id\\": $util.dynamodb.toDynamoDB($ctx.args.input.id)
} )
## [End] Set the primary @key. **

## [Start] Inject @versioned condition.. **
#set( $versionedCondition = {
  \\"expression\\": \\"#version = :expectedVersion\\",
  \\"expressionValues\\": {
      \\":expectedVersion\\":     $util.dynamodb.toDynamoDB($ctx.args.input.expectedVersion)
  },
  \\"expressionNames\\": {
      \\"#version\\": \\"version\\"
  }
} )
#set( $newVersion = $ctx.args.input.expectedVersion + 1 )
$util.qr($ctx.args.input.put(\\"version\\", $newVersion))
$util.qr($ctx.args.input.remove(\\"expectedVersion\\"))
## [End] Inject @versioned condition.. **

#if( $authCondition && $authCondition.expression != \\"\\" )
  #set( $condition = $authCondition )
  #if( $modelObjectKey )
    #foreach( $entry in $modelObjectKey.entrySet() )
      $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\\"))
      $util.qr($condition.expressionNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
    #end
  #else
    $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_exists(#id)\\"))
    $util.qr($condition.expressionNames.put(\\"#id\\", \\"id\\"))
  #end
#else
  #if( $modelObjectKey )
    #set( $condition = {
  \\"expression\\": \\"\\",
  \\"expressionNames\\": {},
  \\"expressionValues\\": {}
} )
    #foreach( $entry in $modelObjectKey.entrySet() )
      #if( $velocityCount == 1 )
        $util.qr($condition.put(\\"expression\\", \\"attribute_exists(#keyCondition$velocityCount)\\"))
      #else
        $util.qr($condition.put(\\"expression\\", \\"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\\"))
      #end
      $util.qr($condition.expressionNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
    #end
  #else
    #set( $condition = {
  \\"expression\\": \\"attribute_exists(#id)\\",
  \\"expressionNames\\": {
      \\"#id\\": \\"id\\"
  },
  \\"expressionValues\\": {}
} )
  #end
#end
## Automatically set the updatedAt timestamp. **
$util.qr($context.args.input.put(\\"updatedAt\\", $util.defaultIfNull($ctx.args.input.updatedAt, $util.time.nowISO8601())))
## Update condition if type is @versioned **
#if( $versionedCondition )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $versionedCondition.expression\\"))
  $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))
  $util.qr($condition.expressionValues.putAll($versionedCondition.expressionValues))
#end
#if( $context.args.condition )
  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
  $util.qr($condition.put(\\"expression\\", \\"($condition.expression) AND $conditionFilterExpressions.expression\\"))
  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
#end
#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
  #set( $condition = {
  \\"expression\\": $condition.expression,
  \\"expressionNames\\": $condition.expressionNames
} )
#end
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($context.args.input, $keyFields).entrySet() )
  #if( !$util.isNull($dynamodbNameOverrideMap) && $dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
{
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
  \\"id\\": {
      \\"S\\": \\"$context.args.input.id\\"
  }
} #end,
  \\"update\\": $util.toJson($update),
  \\"condition\\": $util.toJson($condition)
}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiIssueDataSourceQueryissuesBySiteAreaStatusResolver1BCC78B7": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiIssueDataSourceFCF50787",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "IssueDataSource",
        "FieldName": "issuesBySiteAreaStatus",
        "Kind": "UNIT",
        "RequestMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

## [Start] Set query expression for @key **
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated) && $util.isNullOrBlank($ctx.args.siteName) )
  $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated' you must also provide 'siteName'.\\", \\"InvalidArgumentsError\\")
#end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated) )
  #set( $sortKeyArgumentOperations = $ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.keySet() )
  #if( $sortKeyArgumentOperations.size() > 1 )
    $util.error(\\"Argument areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated must specify at most one key condition operation.\\", \\"InvalidArgumentsError\\")
  #end
  #foreach( $operation in $sortKeyArgumentOperations )
    #if( $operation == \\"between\\" )
      #if( $ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between.size() != 2 )
        $util.error(\\"Argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between' expects exactly two elements.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].created) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].deviceName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].created' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].deviceName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].created) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].deviceName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].created' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].deviceName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].deviceName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].stationName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].deviceName' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].stationName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].deviceName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].stationName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].deviceName' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].stationName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].stationName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].eventDescription) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].stationName' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].eventDescription'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].stationName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].eventDescription) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].stationName' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].eventDescription'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].eventDescription) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].processName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].eventDescription' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].processName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].eventDescription) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].processName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].eventDescription' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].processName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].processName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].status) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].processName' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].status'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].processName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].status) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].processName' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].status'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].status) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].areaName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].status' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].areaName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].status) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].areaName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].status' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].areaName'.\\", \\"InvalidArgumentsError\\")
      #end
    #else
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.get(\\"$operation\\").created) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.get(\\"$operation\\").deviceName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.$operation.created' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.$operation.deviceName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.get(\\"$operation\\").deviceName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.get(\\"$operation\\").stationName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.$operation.deviceName' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.$operation.stationName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.get(\\"$operation\\").stationName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.get(\\"$operation\\").eventDescription) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.$operation.stationName' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.$operation.eventDescription'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.get(\\"$operation\\").eventDescription) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.get(\\"$operation\\").processName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.$operation.eventDescription' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.$operation.processName'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.get(\\"$operation\\").processName) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.get(\\"$operation\\").status) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.$operation.processName' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.$operation.status'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.get(\\"$operation\\").status) && $util.isNullOrBlank($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.get(\\"$operation\\").areaName) )
        $util.error(\\"When providing argument 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.$operation.status' you must also provide 'areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.$operation.areaName'.\\", \\"InvalidArgumentsError\\")
      #end
    #end
  #end
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.siteName) )
  #set( $modelQueryExpression.expression = \\"#siteName = :siteName\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#siteName\\": \\"siteName\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":siteName\\": {
      \\"S\\": \\"$ctx.args.siteName\\"
  }
} )
#end
## [Start] Applying Key Condition **
#set( $sortKeyValue = \\"\\" )
#set( $sortKeyValue2 = \\"\\" )
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated) && !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith) &&  $ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith.areaName != \\"all\\")
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith.areaName) ) #set( $sortKeyValue = \\"$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith.areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith.status) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith.status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith.processName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith.processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith.eventDescription) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith.eventDescription\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith.stationName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith.stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith.deviceName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith.deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith.created) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.beginsWith.created\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"areaName#status#processName#eventDescription#stationName#deviceName#created\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated) && !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between) )
  #if( $ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between.size() != 2 )
    $util.error(\\"Argument areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between expects exactly 2 elements.\\")
  #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].areaName) ) #set( $sortKeyValue = \\"$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].status) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].processName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].eventDescription) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].eventDescription\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].stationName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].deviceName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].created) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[0].created\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].areaName) ) #set( $sortKeyValue2 = \\"$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].status) ) #set( $sortKeyValue2 = \\"$sortKeyValue2#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].processName) ) #set( $sortKeyValue2 = \\"$sortKeyValue2#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].eventDescription) ) #set( $sortKeyValue2 = \\"$sortKeyValue2#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].eventDescription\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].stationName) ) #set( $sortKeyValue2 = \\"$sortKeyValue2#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].deviceName) ) #set( $sortKeyValue2 = \\"$sortKeyValue2#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].created) ) #set( $sortKeyValue2 = \\"$sortKeyValue2#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.between[1].created\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"areaName#status#processName#eventDescription#stationName#deviceName#created\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$sortKeyValue\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$sortKeyValue2\\" }))
#end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated) && !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.eq) )
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.eq.areaName) ) #set( $sortKeyValue = \\"$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.eq.areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.eq.status) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.eq.status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.eq.processName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.eq.processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.eq.eventDescription) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.eq.eventDescription\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.eq.stationName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.eq.stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.eq.deviceName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.eq.deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.eq.created) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.eq.created\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"areaName#status#processName#eventDescription#stationName#deviceName#created\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated) && !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.lt) )
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.lt.areaName) ) #set( $sortKeyValue = \\"$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.lt.areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.lt.status) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.lt.status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.lt.processName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.lt.processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.lt.eventDescription) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.lt.eventDescription\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.lt.stationName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.lt.stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.lt.deviceName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.lt.deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.lt.created) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.lt.created\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"areaName#status#processName#eventDescription#stationName#deviceName#created\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated) && !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.le) )
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.le.areaName) ) #set( $sortKeyValue = \\"$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.le.areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.le.status) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.le.status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.le.processName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.le.processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.le.eventDescription) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.le.eventDescription\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.le.stationName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.le.stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.le.deviceName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.le.deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.le.created) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.le.created\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"areaName#status#processName#eventDescription#stationName#deviceName#created\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated) && !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.gt) )
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.gt.areaName) ) #set( $sortKeyValue = \\"$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.gt.areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.gt.status) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.gt.status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.gt.processName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.gt.processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.gt.eventDescription) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.gt.eventDescription\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.gt.stationName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.gt.stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.gt.deviceName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.gt.deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.gt.created) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.gt.created\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"areaName#status#processName#eventDescription#stationName#deviceName#created\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated) && !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.ge) )
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.ge.areaName) ) #set( $sortKeyValue = \\"$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.ge.areaName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.ge.status) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.ge.status\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.ge.processName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.ge.processName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.ge.eventDescription) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.ge.eventDescription\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.ge.stationName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.ge.stationName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.ge.deviceName) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.ge.deviceName\\" ) #end
#if( !$util.isNull($ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.ge.created) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated.ge.created\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"areaName#status#processName#eventDescription#stationName#deviceName#created\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end


## [End] Applying Key Condition **
## [End] Set query expression for @key **
#set( $limit = $util.defaultIfNull($context.args.limit, 10) )
#set( $QueryRequest = {
  \\"version\\": \\"2017-02-28\\",
  \\"operation\\": \\"Query\\",
  \\"limit\\": $limit,
  \\"query\\": $modelQueryExpression,
  \\"index\\": \\"BySiteAreaStatus-index\\"
} )
#if( !$util.isNull($ctx.args.sortDirection)
                    && $ctx.args.sortDirection == \\"DESC\\" )
  #set( $QueryRequest.scanIndexForward = false )
#else
  #set( $QueryRequest.scanIndexForward = true )
#end
#if( $context.args.nextToken ) #set( $QueryRequest.nextToken = \\"$context.args.nextToken\\" ) #end
#if( $context.args.filter ) #set( $QueryRequest.filter = $util.parseJson(\\"$util.transform.toDynamoDBFilterExpression($ctx.args.filter)\\") ) #end
$util.toJson($QueryRequest)",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end
## Pass back the result from DynamoDB. **

## If permission exists, remove unauthorized ones.
#if ($ctx.stash.permissionCheck && !$ctx.prev.result.isEmpty())
  #set ($currentResult = $ctx.result.items)
  #set ($permissions = $ctx.prev.result)
  #set ($result = {})
  #set ($items = [])
  #set ($allowedValues = [])

  ## Check if this is for issue or others.
  #if ($ctx.stash.type == \\"issue\\")
    ## Check site name
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.sites)
        #if ($allowedValue.name == $value.siteName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check area name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.areas)
        #if ($allowedValue.name == $value.areaName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check process name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.processes)
        #if ($allowedValue.name == $value.processName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check station name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.stations)
        #if ($allowedValue.name == $value.stationName)
          $util.qr($items.add($value))
        #end
      #end
    #end

    ## Check device name
    #set ($currentResult = $items)
    #set ($items = [])
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $permissions.devices)
        #if ($allowedValue.name == $value.deviceName)
          $util.qr($items.add($value))
        #end
      #end
    #end
  #else
    #if ($ctx.stash.type == \\"site\\")
      #set ($allowedValues = $permissions.sites)
    #elseif ($ctx.stash.type == \\"area\\")
      #set ($allowedValues = $permissions.areas)
    #elseif ($ctx.stash.type == \\"process\\")
      #set ($allowedValues = $permissions.processes)
    #elseif ($ctx.stash.type == \\"station\\")
      #set ($allowedValues = $permissions.stations)
    #elseif ($ctx.stash.type == \\"device\\")
      #set ($allowedValues = $permissions.devices)
    #elseif ($ctx.stash.type == \\"event\\")
      #set ($allowedValues = $permissions.processes)
    #end

    ## For event, it checks permission with process ID because there's no such permission for event.
    #foreach ($value in $currentResult)
      #foreach ($allowedValue in $allowedValues)
        #if ($ctx.stash.type == \\"event\\")
          #if ($allowedValue.id == $value.eventProcessId)
            $util.qr($items.add($value))
          #end
        #else
          #if ($allowedValue.id == $value.id)
            $util.qr($items.add($value))
          #end
        #end
      #end
    #end
  #end

  ## Check if nextToken is available.
  #if ($ctx.result.nextToken)
    $util.qr($result.put(\\"nextToken\\", $ctx.result.nextToken))
  #end

  $util.qr($result.put(\\"items\\", $items))
  $util.toJson($result)
#else
  $util.toJson($ctx.result)
#end",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiIssueDataSourceServiceRole7CFC1804": Object {
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "Service": "appsync.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "BackEndAppSyncApiGraphqlApiIssueDataSourceServiceRoleDefaultPolicy1F51834A": Object {
      "Properties": Object {
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": Array [
                "dynamodb:BatchGetItem",
                "dynamodb:GetRecords",
                "dynamodb:GetShardIterator",
                "dynamodb:Query",
                "dynamodb:GetItem",
                "dynamodb:Scan",
                "dynamodb:ConditionCheckItem",
                "dynamodb:BatchWriteItem",
                "dynamodb:PutItem",
                "dynamodb:UpdateItem",
                "dynamodb:DeleteItem",
              ],
              "Effect": "Allow",
              "Resource": Array [
                Object {
                  "Fn::GetAtt": Array [
                    "AVAIssuesTable",
                    "Arn",
                  ],
                },
                Object {
                  "Fn::Join": Array [
                    "",
                    Array [
                      Object {
                        "Fn::GetAtt": Array [
                          "AVAIssuesTable",
                          "Arn",
                        ],
                      },
                      "/index/*",
                    ],
                  ],
                },
              ],
            },
          ],
          "Version": "2012-10-17",
        },
        "PolicyName": "BackEndAppSyncApiGraphqlApiIssueDataSourceServiceRoleDefaultPolicy1F51834A",
        "Roles": Array [
          Object {
            "Ref": "BackEndAppSyncApiGraphqlApiIssueDataSourceServiceRole7CFC1804",
          },
        ],
      },
      "Type": "AWS::IAM::Policy",
    },
    "BackEndAppSyncApiGraphqlApiMutationcreateAreaResolver615F7EAD": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "createArea",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceListAreasFunctionFunctionC29C1C3E",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceCreateAreaFunctionFunctionED44AF26",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "{}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiMutationcreateDeviceResolverB019C2E8": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "createDevice",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceListDevicesFunctionFunction0FAC671B",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceCreateDeviceFunctionFunction7ED8FEDE",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "{}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiMutationcreateEventResolver71AF028A": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "createEvent",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceListEventsFunctionFunctionD03130CF",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceCreateEventFunctionFunctionE89A7134",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVALambdaDataSourceHandleEventSnsFunctionFunction6CECC98A",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "{}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiMutationcreateProcessResolver8A885B44": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "createProcess",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceListProcessesFunctionFunctionAE27334B",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceCreateProcessFunctionFunctionEF12FD3D",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "{}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiMutationcreateRootCauseResolverA5C67D9B": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "createRootCause",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceListRootCausesByNameFunctionFunction050B810E",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceCreateRootCauseFunctionFunction7844347F",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "{}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiMutationcreateSiteResolver4D8DB703": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "createSite",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceListSitesByNameFunctionFunction5D5DFF68",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceCreateSiteFunctionFunctionEA8154A6",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "{}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiMutationcreateStationResolverF8B05E94": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "createStation",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceListStationsFunctionFunctionEAA3A1EC",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceCreateStationFunctionFunction2E6FB5D2",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "{}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiMutationdeleteEventResolver1A26DF69": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "deleteEvent",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceDeleteEventFunctionFunctionDB61489B",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVALambdaDataSourceHandleEventSnsFunctionFunction6CECC98A",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "{}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiMutationupdateEventResolver0BE2701D": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "updateEvent",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceUpdateEventFunctionFunction5CE7A71C",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVALambdaDataSourceHandleEventSnsFunctionFunction6CECC98A",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "{}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Mutation",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiNoneDataSource58DD79A0": Object {
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "Name": "NoneDataSource",
        "Type": "NONE",
      },
      "Type": "AWS::AppSync::DataSource",
    },
    "BackEndAppSyncApiGraphqlApiQueryissuesByDeviceResolverA2CF0EDF": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "issuesByDevice",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceGetPermissionsForAssociateGroupUserFunctionFunctionDF3C35D5",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiIssueDataSourceListIssuesByDeviceFunctionFunction988D9D87",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "$util.qr($ctx.stash.put(\\"permissionCheck\\", true))
      $util.qr($ctx.stash.put(\\"type\\", \\"issue\\"))
      {}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiQuerylistAreasResolver70007576": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "listAreas",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceGetPermissionsForAssociateGroupUserFunctionFunctionDF3C35D5",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceListAreasFunctionFunctionC29C1C3E",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "$util.qr($ctx.stash.put(\\"permissionCheck\\", true))
        $util.qr($ctx.stash.put(\\"type\\", \\"area\\"))
        {}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiQuerylistDevicesResolverD3321F1D": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "listDevices",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceGetPermissionsForAssociateGroupUserFunctionFunctionDF3C35D5",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceListDevicesFunctionFunction0FAC671B",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "$util.qr($ctx.stash.put(\\"permissionCheck\\", true))
      $util.qr($ctx.stash.put(\\"type\\", \\"device\\"))
      {}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiQuerylistEventsResolver9FDD8C0D": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "listEvents",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceGetPermissionsForAssociateGroupUserFunctionFunctionDF3C35D5",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceListEventsFunctionFunctionD03130CF",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "$util.qr($ctx.stash.put(\\"permissionCheck\\", true))
        $util.qr($ctx.stash.put(\\"type\\", \\"event\\"))
        {}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiQuerylistProcessesResolverAE2E31D1": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "listProcesses",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceGetPermissionsForAssociateGroupUserFunctionFunctionDF3C35D5",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceListProcessesFunctionFunctionAE27334B",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "$util.qr($ctx.stash.put(\\"permissionCheck\\", true))
      $util.qr($ctx.stash.put(\\"type\\", \\"process\\"))
      {}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiQuerylistSitesResolver692CDB80": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "listSites",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceGetPermissionsForAssociateGroupUserFunctionFunctionDF3C35D5",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceListSitesFunctionFunction36AD4955",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "$util.qr($ctx.stash.put(\\"permissionCheck\\", true))
        $util.qr($ctx.stash.put(\\"type\\", \\"site\\"))
        {}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiQuerylistStationsResolver7D052C15": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "FieldName": "listStations",
        "Kind": "PIPELINE",
        "PipelineConfig": Object {
          "Functions": Array [
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceGetPermissionsForAssociateGroupUserFunctionFunctionDF3C35D5",
                "FunctionId",
              ],
            },
            Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApiAVADataSourceListStationsFunctionFunctionEAA3A1EC",
                "FunctionId",
              ],
            },
          ],
        },
        "RequestMappingTemplate": "$util.qr($ctx.stash.put(\\"permissionCheck\\", true))
        $util.qr($ctx.stash.put(\\"type\\", \\"station\\"))
        {}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error
#if ($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## Pass back the result from DynamoDB.
$util.toJson($ctx.prev.result)",
        "TypeName": "Query",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiSchema569E0B17": Object {
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "Definition": "# Schema
schema {
	query: Query
	mutation: Mutation
	subscription: Subscription
}

# Types
type Query {
	getSite(id: ID!, type: String!): Site @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	listSites(limit: Int, nextToken: String): SiteConnection @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\", \\"EngineerGroup\\", \\"AssociateGroup\\"])
	getArea(id: ID!, type: String!): Area @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	listAreas(areaSiteId: ID!, name: String, limit: Int, nextToken: String): AreaConnection @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\", \\"EngineerGroup\\", \\"AssociateGroup\\"])
	getProcess(id: ID!, type: String!): Process @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	listProcesses(processAreaId: ID!, name: String, limit: Int, nextToken: String): ProcessConnection @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\", \\"EngineerGroup\\", \\"AssociateGroup\\"])
	getEvent(id: ID!, type: String!): Event @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\", \\"EngineerGroup\\", \\"AssociateGroup\\"])
	listEvents(parentId: ID, eventProcessId: ID, name: String, limit: Int, nextToken: String): EventConnection @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\", \\"EngineerGroup\\", \\"AssociateGroup\\"])
	getStation(id: ID!, type: String!): Station @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	listStations(stationAreaId: ID!, name: String, limit: Int, nextToken: String): StationConnection @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\", \\"EngineerGroup\\", \\"AssociateGroup\\"])
	listDevices(deviceStationId: ID!, name: String, limit: Int, nextToken: String): DeviceConnection @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\", \\"EngineerGroup\\", \\"AssociateGroup\\"])
	issuesBySiteAreaStatus(
		siteName: String,
		areaNameStatusProcessNameEventDescriptionStationNameDeviceNameCreated: IssueBySiteAreaStatusCompositeKeyConditionInput,
		filter: IssueFilterInput,
		limit: Int,
		nextToken: String
	): IssueConnection @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\", \\"EngineerGroup\\"])
	issuesByDevice(
		siteName: String,
		areaNameStatusProcessNameStationNameDeviceNameCreated: IssueByDeviceCompositeKeyConditionInput,
		limit: Int,
		nextToken: String
	): IssueConnection @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\", \\"EngineerGroup\\", \\"AssociateGroup\\"])
	getPermission(id: ID!, type: String!): Permission @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\", \\"EngineerGroup\\", \\"AssociateGroup\\"])
	listPermissions(limit: Int, nextToken: String): PermissionConnection @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	listRootCauses(limit: Int, nextToken: String): RootCauseConnection @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\", \\"EngineerGroup\\"])
	getPrevDayIssuesStats: PrevDayIssuesStats @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\"])
}

type Mutation {
	createSite(id: ID, type: String!, name: String!, description: String!): Site @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	deleteSite(id: ID!, type: String!): Site @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	createArea(id: ID, type: String!, areaSiteId: ID!, name: String!, description: String!): Area @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	deleteArea(id: ID!, type: String!): Area @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	createProcess(id: ID, type: String!, processAreaId: ID!, name: String!, description: String!): Process @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	deleteProcess(id: ID!, type: String!): Process @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	createEvent(
		id: ID,
		type: String!,
		eventProcessId: ID,
		parentId: ID,
		name: String!,
		description: String!,
		priority: Priority!,
		sms: String,
		email: String,
		rootCauses: [String],
		eventImgKey: String,
		eventType: String,
		alias: String
	): Event @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	updateEvent(id: ID!, sms: String, email: String, previousSms: String, previousEmail: String, rootCauses: [String], eventImgKey: String, alias: String): Event @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	deleteEvent(id: ID!, type: String!): Event @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	createStation(id: ID, type: String!, stationAreaId: ID!, name: String!, description: String!): Station @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	deleteStation(id: ID!, type: String!): Station @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	createDevice(id: ID, type: String!, deviceStationId: ID!, name: String!, description: String!, alias: String): Device @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	deleteDevice(id: ID!, type: String!): Device @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	createIssue(input: CreateIssueInput!): Issue @aws_iam @aws_cognito_user_pools
	updateIssue(input: UpdateIssueInput!): Issue @aws_iam @aws_cognito_user_pools
	putPermission(input: PermissionInput!): Permission @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	deletePermission(id: ID!, type: String!): Permission @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	createRootCause(id: ID, type: String!, name: String!): RootCause @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	deleteRootCause(id: ID!, type: String!): RootCause @aws_auth(cognito_groups: [\\"AdminGroup\\"])
}

type Subscription {
	onCreateIssue: Issue @aws_subscribe(mutations: [\\"createIssue\\"]) @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\", \\"EngineerGroup\\", \\"AssociateGroup\\"])
	onUpdateIssue: Issue @aws_subscribe(mutations: [\\"updateIssue\\"]) @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\", \\"EngineerGroup\\", \\"AssociateGroup\\"])
	onPutPermission: Permission @aws_subscribe(mutations: [\\"putPermission\\"]) @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\", \\"EngineerGroup\\", \\"AssociateGroup\\"])
	onDeletePermission: Permission @aws_subscribe(mutations: [\\"deletePermission\\"]) @aws_auth(cognito_groups: [\\"AdminGroup\\", \\"ManagerGroup\\", \\"EngineerGroup\\", \\"AssociateGroup\\"])
	onCreateRootCause: RootCause @aws_subscribe(mutations: [\\"createRootCause\\"]) @aws_auth(cognito_groups: [\\"AdminGroup\\"])
	onDeleteRootCause: RootCause @aws_subscribe(mutations: [\\"deleteRootCause\\"]) @aws_auth(cognito_groups: [\\"AdminGroup\\"])
}

type Area {
	id: ID!
	type: String!
	site: Site!
	name: String!
	process(
		limit: Int,
		nextToken: String
	): ProcessConnection
	station(
		limit: Int,
		nextToken: String
	): StationConnection
	description: String!
	version: Int!
}

type AreaConnection {
	items: [Area]
	nextToken: String
}

type Device {
	id: ID!
	type: String!
	name: String!
	description: String!
	station: Station!
	version: Int!
	alias: String
}

type DeviceConnection {
	items: [Device]
	nextToken: String
}

type Event {
	id: ID!
	type: String
	name: String!
	description: String!
	priority: Priority!
	sms: String
	email: String
	process: Process!
	version: Int!
	rootCauses: [String]
	eventImgKey: String
	eventType: String
	alias: String
	eventProcessId: ID!
	parentId: ID!
}

type EventConnection {
	items: [Event]
	nextToken: String
}

type Issue @aws_iam @aws_cognito_user_pools {
	id: ID!
	eventId: String!
	eventDescription: String!
	type: String
	priority: Priority!
	siteName: String!
	processName: String!
	areaName: String!
	stationName: String
	deviceName: String
	created: AWSDateTime!
	createdAt: AWSDateTime
	acknowledged: AWSDateTime
	closed: AWSDateTime
	resolutionTime: Int
	acknowledgedTime: Int
	status: Status!
	version: Int!
	rootCause: String
	comment: String
	issueSource: IssueSource!
	createdBy: String!
	closedBy: String
	rejectedBy: String
	acknowledgedBy: String
	additionalDetails: String
}

type IssueConnection @aws_iam @aws_cognito_user_pools {
	items: [Issue]
	nextToken: String
}

type Permission {
	id: ID!
	type: String!
	sites: [PermissionObject]
	areas: [PermissionObject]
	processes: [PermissionObject]
	stations: [PermissionObject]
	devices: [PermissionObject]
	version: Int!
}

type PermissionConnection {
	items: [Permission]
	nextToken: String
}

type PermissionObject {
	id: String!
	name: String!
	parentId: String
}

type Process {
	id: ID!
	type: String!
	name: String!
	description: String!
	area: Area!
	event(
		limit: Int,
		nextToken: String
	): EventConnection
	version: Int!
}

type ProcessConnection {
	items: [Process]
	nextToken: String
}

type RootCause {
	id: ID!
	type: String!
	name: String!
}

type RootCauseConnection {
	items: [RootCause]
	nextToken: String
}

type Site {
	id: ID!
	type: String!
	name: String!
	area(
		limit: Int,
		nextToken: String
	): AreaConnection
	description: String
	version: Int!
}

type SiteConnection {
	items: [Site]
	nextToken: String
}

type Station {
	id: ID!
	type: String!
	name: String!
	description: String
	area: Area!
	device(
		limit: Int,
		nextToken: String
	): DeviceConnection
	version: Int!
}

type StationConnection {
	items: [Station]
	nextToken: String
}

type PrevDayIssuesStats {
	open: Int
	acknowledged: Int
	closed: Int
	lastThreeHours: Int
}

# Inputs
input CreateIssueInput {
	id: ID!
	eventId: String!
	eventDescription: String!
	type: String
	priority: Priority!
	siteName: String!
	processName: String!
	areaName: String!
	stationName: String!
	deviceName: String!
	created: AWSDateTime!
	acknowledged: AWSDateTime
	closed: AWSDateTime
	resolutionTime: Int
	acknowledgedTime: Int
	status: Status!
	issueSource: IssueSource!
	createdBy: String!
	additionalDetails: String
	eventType: String
}

input UpdateIssueInput {
	id: ID!
	eventId: String!
	eventDescription: String
	type: String
	priority: Priority
	siteName: String
	processName: String
	areaName: String
	stationName: String
	deviceName: String
	created: AWSDateTime
	createdAt: AWSDateTime
	acknowledged: AWSDateTime
	closed: AWSDateTime
	resolutionTime: Int
	acknowledgedTime: Int
	status: Status
	expectedVersion: Int!
	rootCause: String
	comment: String
	createdBy: String
	closedBy: String
	acknowledgedBy: String
	rejectedBy: String
	additionalDetails: String
	eventType: String
}

input IssueByDeviceCompositeKeyConditionInput {
	eq: IssueByDeviceCompositeKeyInput
	le: IssueByDeviceCompositeKeyInput
	lt: IssueByDeviceCompositeKeyInput
	ge: IssueByDeviceCompositeKeyInput
	gt: IssueByDeviceCompositeKeyInput
	between: [IssueByDeviceCompositeKeyInput]
	beginsWith: IssueByDeviceCompositeKeyInput
}

input IssueByDeviceCompositeKeyInput {
	areaName: String
	status: Status
	processName: String
	stationName: String
	deviceName: String
	created: String
}

input IssueBySiteAreaStatusCompositeKeyConditionInput {
	eq: IssueBySiteAreaStatusCompositeKeyInput
	le: IssueBySiteAreaStatusCompositeKeyInput
	lt: IssueBySiteAreaStatusCompositeKeyInput
	ge: IssueBySiteAreaStatusCompositeKeyInput
	gt: IssueBySiteAreaStatusCompositeKeyInput
	between: [IssueBySiteAreaStatusCompositeKeyInput]
	beginsWith: IssueBySiteAreaStatusCompositeKeyInput
}

input IssueBySiteAreaStatusCompositeKeyInput {
	areaName: String
	status: Status
	processName: String
	eventDescription: String
	stationName: String
	deviceName: String
	created: String
}

input IssueFilterInput {
	created: StringInput
	status: StringInput
}

input PermissionInput {
	id: ID!
	sites: [PermissionObjectInput]
	areas: [PermissionObjectInput]
	processes: [PermissionObjectInput]
	stations: [PermissionObjectInput]
	devices: [PermissionObjectInput]
	version: Int!
}

input PermissionObjectInput {
	id: String!
	name: String!
	parentId: String
}

input RootCauseInput {
	id: String!
	name: String!
}

input StringInput {
	gt: String
	eq: String
	between: [String]
}

# Enums
enum Priority {
	low
	medium
	high
	critical
}

enum Status {
	open
	acknowledged
	closed
	inprogress
	rejected
}

enum IssueSource {
	webClient
	s3File
	device
}",
      },
      "Type": "AWS::AppSync::GraphQLSchema",
    },
    "BackEndAppSyncApiGraphqlApiSubscriptiononCreateIssueResolver6C98D73C": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiNoneDataSource58DD79A0",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "NoneDataSource",
        "FieldName": "onCreateIssue",
        "Kind": "UNIT",
        "RequestMappingTemplate": "
        {
          \\"version\\": \\"2018-05-29\\",
          \\"payload\\": {}
        }",
        "ResponseMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

$util.toJson(null)",
        "TypeName": "Subscription",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiSubscriptiononCreateRootCauseResolverC03ED517": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiNoneDataSource58DD79A0",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "NoneDataSource",
        "FieldName": "onCreateRootCause",
        "Kind": "UNIT",
        "RequestMappingTemplate": "
        {
          \\"version\\": \\"2018-05-29\\",
          \\"payload\\": {}
        }",
        "ResponseMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

$util.toJson(null)",
        "TypeName": "Subscription",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiSubscriptiononDeletePermissionResolver3FA3749D": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiNoneDataSource58DD79A0",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "NoneDataSource",
        "FieldName": "onDeletePermission",
        "Kind": "UNIT",
        "RequestMappingTemplate": "
        {
          \\"version\\": \\"2018-05-29\\",
          \\"payload\\": {}
        }",
        "ResponseMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

$util.toJson(null)",
        "TypeName": "Subscription",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiSubscriptiononDeleteRootCauseResolverC1F0AC99": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiNoneDataSource58DD79A0",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "NoneDataSource",
        "FieldName": "onDeleteRootCause",
        "Kind": "UNIT",
        "RequestMappingTemplate": "
        {
          \\"version\\": \\"2018-05-29\\",
          \\"payload\\": {}
        }",
        "ResponseMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

$util.toJson(null)",
        "TypeName": "Subscription",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiSubscriptiononPutPermissionResolverF19C7DED": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiNoneDataSource58DD79A0",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "NoneDataSource",
        "FieldName": "onPutPermission",
        "Kind": "UNIT",
        "RequestMappingTemplate": "
        {
          \\"version\\": \\"2018-05-29\\",
          \\"payload\\": {}
        }",
        "ResponseMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

$util.toJson(null)",
        "TypeName": "Subscription",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiGraphqlApiSubscriptiononUpdateIssueResolverDA8B112A": Object {
      "DependsOn": Array [
        "BackEndAppSyncApiGraphqlApiNoneDataSource58DD79A0",
        "BackEndAppSyncApiGraphqlApiSchema569E0B17",
      ],
      "Properties": Object {
        "ApiId": Object {
          "Fn::GetAtt": Array [
            "BackEndAppSyncApiGraphqlApi7F48FCAE",
            "ApiId",
          ],
        },
        "DataSourceName": "NoneDataSource",
        "FieldName": "onUpdateIssue",
        "Kind": "UNIT",
        "RequestMappingTemplate": "
        {
          \\"version\\": \\"2018-05-29\\",
          \\"payload\\": {}
        }",
        "ResponseMappingTemplate": "## Check authorization
#set ($isAllowed = false)
#set ($userGroups = $util.defaultIfNull($ctx.identity.claims.get(\\"cognito:groups\\"), []))
#set ($allowedGroups = [\\"AdminGroup\\",\\"ManagerGroup\\",\\"EngineerGroup\\",\\"AssociateGroup\\"])
#foreach ($userGroup in $userGroups)
  #if ($allowedGroups.contains($userGroup))
    #set ($isAllowed = true)
    #break
  #end
#end

## Throw authorized if the user is not authorized.
#if ($isAllowed == false)
  $util.unauthorized()
#end

$util.toJson(null)",
        "TypeName": "Subscription",
      },
      "Type": "AWS::AppSync::Resolver",
    },
    "BackEndAppSyncApiLogRoleD851D1DD": Object {
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "Service": "appsync.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "Path": "/",
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "BackEndAppSyncApiLogRoleDefaultPolicyBBD6EC4E": Object {
      "Properties": Object {
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": Array [
                "logs:CreateLogGroup",
                "logs:CreateLogStream",
                "logs:PutLogEvents",
              ],
              "Effect": "Allow",
              "Resource": Object {
                "Fn::Join": Array [
                  "",
                  Array [
                    "arn:",
                    Object {
                      "Ref": "AWS::Partition",
                    },
                    ":logs:",
                    Object {
                      "Ref": "AWS::Region",
                    },
                    ":",
                    Object {
                      "Ref": "AWS::AccountId",
                    },
                    ":log-group:*",
                  ],
                ],
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "PolicyName": "BackEndAppSyncApiLogRoleDefaultPolicyBBD6EC4E",
        "Roles": Array [
          Object {
            "Ref": "BackEndAppSyncApiLogRoleD851D1DD",
          },
        ],
      },
      "Type": "AWS::IAM::Policy",
    },
    "BackEndDataAnalysisAvaEtlCleanupJobE10402AE": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "Properties": Object {
        "Command": Object {
          "Name": "glueetl",
          "PythonVersion": "3",
          "ScriptLocation": Object {
            "Fn::Join": Array [
              "",
              Array [
                "s3://",
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3BucketPrefix",
                  ],
                },
                "-",
                Object {
                  "Ref": "AWS::Region",
                },
                "/",
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3KeyPrefix",
                  ],
                },
                "/glue-job-scripts/etl-cleanup.py",
              ],
            ],
          },
        },
        "DefaultArguments": Object {
          "--enable-metrics": "",
          "--glue_output_bucket": Object {
            "Ref": "AvaGlueOutputBucket",
          },
          "--glue_output_s3_key_prefix": "glue/ddb-output",
          "--job-bookmark-option": "job-bookmark-enable",
          "--job-language": "python",
          "--region": Object {
            "Ref": "AWS::Region",
          },
          "--solution_id": "SOxyz",
          "--solution_version": "v3.0.0",
        },
        "ExecutionProperty": Object {
          "MaxConcurrentRuns": 1,
        },
        "GlueVersion": "2.0",
        "Name": "amazon-virtual-andon-etl-cleanup",
        "NumberOfWorkers": 2,
        "Role": Object {
          "Fn::GetAtt": Array [
            "BackEndDataAnalysisAvaEtlCleanupJobRoleB2319443",
            "Arn",
          ],
        },
        "Tags": Object {
          "SolutionId": "SOxyz",
        },
        "Timeout": 60,
        "WorkerType": "Standard",
      },
      "Type": "AWS::Glue::Job",
    },
    "BackEndDataAnalysisAvaEtlCleanupJobRoleB2319443": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "Service": "glue.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "ManagedPolicyArns": Array [
          Object {
            "Fn::Join": Array [
              "",
              Array [
                "arn:",
                Object {
                  "Ref": "AWS::Partition",
                },
                ":iam::aws:policy/service-role/AWSGlueServiceRole",
              ],
            ],
          },
        ],
        "Policies": Array [
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": "s3:GetObject",
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        "arn:",
                        Object {
                          "Ref": "AWS::Partition",
                        },
                        ":s3:::",
                        Object {
                          "Fn::FindInMap": Array [
                            "Solution",
                            "Config",
                            "S3BucketPrefix",
                          ],
                        },
                        "-",
                        Object {
                          "Ref": "AWS::Region",
                        },
                        "/",
                        Object {
                          "Fn::FindInMap": Array [
                            "Solution",
                            "Config",
                            "S3KeyPrefix",
                          ],
                        },
                        "/glue-job-scripts/etl-cleanup.py",
                      ],
                    ],
                  },
                },
                Object {
                  "Action": "s3:DeleteObject",
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        Object {
                          "Fn::GetAtt": Array [
                            "AvaGlueOutputBucket",
                            "Arn",
                          ],
                        },
                        "/glue/ddb-output*",
                      ],
                    ],
                  },
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "S3Policy",
          },
        ],
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "BackEndDataAnalysisAvaEtlDataExportJob4C698717": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "Properties": Object {
        "Command": Object {
          "Name": "glueetl",
          "PythonVersion": "3",
          "ScriptLocation": Object {
            "Fn::Join": Array [
              "",
              Array [
                "s3://",
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3BucketPrefix",
                  ],
                },
                "-",
                Object {
                  "Ref": "AWS::Region",
                },
                "/",
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3KeyPrefix",
                  ],
                },
                "/glue-job-scripts/etl-data-export.py",
              ],
            ],
          },
        },
        "DefaultArguments": Object {
          "--ddb_data_hierarchy_table_name": Object {
            "Ref": "AVADataHierarchyTable",
          },
          "--ddb_issues_table_name": Object {
            "Ref": "AVAIssuesTable",
          },
          "--enable-metrics": "",
          "--glue_data_hierarchy_table_name": Object {
            "Ref": "AvaGlueDataHierarchyTable",
          },
          "--glue_db_name": Object {
            "Ref": "AvaGlueDatabase",
          },
          "--glue_issues_table_name": Object {
            "Ref": "AvaGlueIssuesTable",
          },
          "--glue_output_bucket": Object {
            "Ref": "AvaGlueOutputBucket",
          },
          "--job-bookmark-option": "job-bookmark-enable",
          "--job-language": "python",
          "--region": Object {
            "Ref": "AWS::Region",
          },
          "--solution_id": "SOxyz",
          "--solution_version": "v3.0.0",
        },
        "ExecutionProperty": Object {
          "MaxConcurrentRuns": 2,
        },
        "GlueVersion": "2.0",
        "Name": "amazon-virtual-andon-etl-data-export",
        "NumberOfWorkers": 2,
        "Role": Object {
          "Fn::GetAtt": Array [
            "BackEndDataAnalysisAvaEtlDataExportJobRole80319EC7",
            "Arn",
          ],
        },
        "Tags": Object {
          "SolutionId": "SOxyz",
        },
        "Timeout": 60,
        "WorkerType": "Standard",
      },
      "Type": "AWS::Glue::Job",
    },
    "BackEndDataAnalysisAvaEtlDataExportJobRole80319EC7": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "W11",
              "reason": "* is required for the s3:ListAllMyBuckets permission",
            },
          ],
        },
      },
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "Service": "glue.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "ManagedPolicyArns": Array [
          Object {
            "Fn::Join": Array [
              "",
              Array [
                "arn:",
                Object {
                  "Ref": "AWS::Partition",
                },
                ":iam::aws:policy/service-role/AWSGlueServiceRole",
              ],
            ],
          },
        ],
        "Policies": Array [
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": Array [
                    "dynamodb:Scan",
                    "dynamodb:DescribeTable",
                  ],
                  "Effect": "Allow",
                  "Resource": Array [
                    Object {
                      "Fn::GetAtt": Array [
                        "AVAIssuesTable",
                        "Arn",
                      ],
                    },
                    Object {
                      "Fn::GetAtt": Array [
                        "AVADataHierarchyTable",
                        "Arn",
                      ],
                    },
                  ],
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "DDBPolicy",
          },
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": "s3:GetObject",
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        "arn:",
                        Object {
                          "Ref": "AWS::Partition",
                        },
                        ":s3:::",
                        Object {
                          "Fn::FindInMap": Array [
                            "Solution",
                            "Config",
                            "S3BucketPrefix",
                          ],
                        },
                        "-",
                        Object {
                          "Ref": "AWS::Region",
                        },
                        "/",
                        Object {
                          "Fn::FindInMap": Array [
                            "Solution",
                            "Config",
                            "S3KeyPrefix",
                          ],
                        },
                        "/glue-job-scripts/etl-data-export.py",
                      ],
                    ],
                  },
                },
                Object {
                  "Action": Array [
                    "s3:PutObject",
                    "s3:DeleteObject",
                    "s3:GetObject",
                  ],
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        Object {
                          "Fn::GetAtt": Array [
                            "AvaGlueOutputBucket",
                            "Arn",
                          ],
                        },
                        "/*",
                      ],
                    ],
                  },
                },
                Object {
                  "Action": Array [
                    "s3:GetBucketLocation",
                    "s3:ListBucket",
                    "s3:GetBucketAcl",
                    "s3:CreateBucket",
                  ],
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::GetAtt": Array [
                      "AvaGlueOutputBucket",
                      "Arn",
                    ],
                  },
                },
                Object {
                  "Action": "s3:ListAllMyBuckets",
                  "Effect": "Allow",
                  "Resource": "*",
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "S3Policy",
          },
        ],
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "BackEndDataAnalysisAvaEtlWorkflowA035F2B6": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "Properties": Object {
        "Description": Object {
          "Fn::Join": Array [
            "",
            Array [
              "Workflow for ",
              Object {
                "Ref": "AWS::StackName",
              },
              " CloudFormation stack",
            ],
          ],
        },
        "Tags": Object {
          "SolutionId": "SOxyz",
        },
      },
      "Type": "AWS::Glue::Workflow",
    },
    "BackEndDataAnalysisAvaGlueOutputBucketPolicy99671AB0": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "Properties": Object {
        "Bucket": Object {
          "Ref": "AvaGlueOutputBucket",
        },
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "s3:*",
              "Condition": Object {
                "Bool": Object {
                  "aws:SecureTransport": "False",
                },
              },
              "Effect": "Deny",
              "Principal": Object {
                "AWS": "*",
              },
              "Resource": Array [
                Object {
                  "Fn::GetAtt": Array [
                    "AvaGlueOutputBucket",
                    "Arn",
                  ],
                },
                Object {
                  "Fn::Join": Array [
                    "",
                    Array [
                      Object {
                        "Fn::GetAtt": Array [
                          "AvaGlueOutputBucket",
                          "Arn",
                        ],
                      },
                      "/*",
                    ],
                  ],
                },
              ],
            },
          ],
          "Version": "2012-10-17",
        },
      },
      "Type": "AWS::S3::BucketPolicy",
    },
    "BackEndDataAnalysisCrawler4716D7B2": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "Properties": Object {
        "DatabaseName": Object {
          "Ref": "AvaGlueDatabase",
        },
        "Name": "amazon-virtual-andon-crawler",
        "Role": Object {
          "Fn::GetAtt": Array [
            "BackEndDataAnalysisCrawlerRole22ED7E20",
            "Arn",
          ],
        },
        "Tags": Object {
          "SolutionId": "SOxyz",
        },
        "Targets": Object {
          "DynamoDBTargets": Array [
            Object {
              "Path": Object {
                "Ref": "AVAIssuesTable",
              },
            },
            Object {
              "Path": Object {
                "Ref": "AVADataHierarchyTable",
              },
            },
          ],
        },
      },
      "Type": "AWS::Glue::Crawler",
    },
    "BackEndDataAnalysisCrawlerRole22ED7E20": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "Service": "glue.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "ManagedPolicyArns": Array [
          Object {
            "Fn::Join": Array [
              "",
              Array [
                "arn:",
                Object {
                  "Ref": "AWS::Partition",
                },
                ":iam::aws:policy/service-role/AWSGlueServiceRole",
              ],
            ],
          },
        ],
        "Policies": Array [
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": Array [
                    "dynamodb:Scan",
                    "dynamodb:DescribeTable",
                  ],
                  "Effect": "Allow",
                  "Resource": Array [
                    Object {
                      "Fn::Join": Array [
                        "",
                        Array [
                          Object {
                            "Fn::GetAtt": Array [
                              "AVAIssuesTable",
                              "Arn",
                            ],
                          },
                          "*",
                        ],
                      ],
                    },
                    Object {
                      "Fn::Join": Array [
                        "",
                        Array [
                          Object {
                            "Fn::GetAtt": Array [
                              "AVADataHierarchyTable",
                              "Arn",
                            ],
                          },
                          "*",
                        ],
                      ],
                    },
                  ],
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "DDBPolicy",
          },
        ],
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "BackEndDataAnalysisEtlCleanupJobTrigger627B78C1": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "Properties": Object {
        "Actions": Array [
          Object {
            "JobName": Object {
              "Ref": "BackEndDataAnalysisAvaEtlCleanupJobE10402AE",
            },
          },
        ],
        "Description": "Starts the first job (cleanup job) in the ETL workflow. This job will clean any data from S3 that resulted from a prior ETL workflow",
        "Name": Object {
          "Fn::Join": Array [
            "",
            Array [
              Object {
                "Ref": "AWS::StackName",
              },
              "-EtlCleanupJobTrigger",
            ],
          ],
        },
        "Schedule": "cron(00 00 ? * MON *)",
        "StartOnCreation": true,
        "Tags": Object {
          "SolutionId": "SOxyz",
        },
        "Type": "SCHEDULED",
        "WorkflowName": Object {
          "Ref": "BackEndDataAnalysisAvaEtlWorkflowA035F2B6",
        },
      },
      "Type": "AWS::Glue::Trigger",
    },
    "BackEndDataAnalysisEtlCrawlerTriggerD4CF1A98": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "Properties": Object {
        "Actions": Array [
          Object {
            "CrawlerName": Object {
              "Ref": "BackEndDataAnalysisCrawler4716D7B2",
            },
          },
        ],
        "Description": "Crawls the DynamoDB table to update the Glue Data Catalog",
        "Name": Object {
          "Fn::Join": Array [
            "",
            Array [
              Object {
                "Ref": "AWS::StackName",
              },
              "-EtlCrawlerTrigger",
            ],
          ],
        },
        "Predicate": Object {
          "Conditions": Array [
            Object {
              "JobName": Object {
                "Ref": "BackEndDataAnalysisAvaEtlCleanupJobE10402AE",
              },
              "LogicalOperator": "EQUALS",
              "State": "SUCCEEDED",
            },
          ],
        },
        "StartOnCreation": true,
        "Tags": Object {
          "SolutionId": "SOxyz",
        },
        "Type": "CONDITIONAL",
        "WorkflowName": Object {
          "Ref": "BackEndDataAnalysisAvaEtlWorkflowA035F2B6",
        },
      },
      "Type": "AWS::Glue::Trigger",
    },
    "BackEndDataAnalysisEtlDataHierarchyDataExportJobTriggerDD074455": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "Properties": Object {
        "Actions": Array [
          Object {
            "Arguments": Object {
              "--job_type": "hierarchy",
            },
            "JobName": Object {
              "Ref": "BackEndDataAnalysisAvaEtlDataExportJob4C698717",
            },
          },
        ],
        "Description": "Runs ETL for the Data Hierarchy table to S3",
        "Name": Object {
          "Fn::Join": Array [
            "",
            Array [
              Object {
                "Ref": "AWS::StackName",
              },
              "-EtlDataHierarchyDataExportJobTrigger",
            ],
          ],
        },
        "Predicate": Object {
          "Conditions": Array [
            Object {
              "CrawlState": "SUCCEEDED",
              "CrawlerName": Object {
                "Ref": "BackEndDataAnalysisCrawler4716D7B2",
              },
              "LogicalOperator": "EQUALS",
            },
          ],
        },
        "StartOnCreation": true,
        "Tags": Object {
          "SolutionId": "SOxyz",
        },
        "Type": "CONDITIONAL",
        "WorkflowName": Object {
          "Ref": "BackEndDataAnalysisAvaEtlWorkflowA035F2B6",
        },
      },
      "Type": "AWS::Glue::Trigger",
    },
    "BackEndDataAnalysisEtlIssuesDataExportJobTriggerE26F764D": Object {
      "Condition": "BackEndDataAnalysisGlueWorkflowConditionA63A5CE7",
      "Properties": Object {
        "Actions": Array [
          Object {
            "Arguments": Object {
              "--job_type": "issues",
            },
            "JobName": Object {
              "Ref": "BackEndDataAnalysisAvaEtlDataExportJob4C698717",
            },
          },
        ],
        "Description": "Runs ETL for the Issues table to S3",
        "Name": Object {
          "Fn::Join": Array [
            "",
            Array [
              Object {
                "Ref": "AWS::StackName",
              },
              "-EtlIssuesDataExportJobTrigger",
            ],
          ],
        },
        "Predicate": Object {
          "Conditions": Array [
            Object {
              "CrawlState": "SUCCEEDED",
              "CrawlerName": Object {
                "Ref": "BackEndDataAnalysisCrawler4716D7B2",
              },
              "LogicalOperator": "EQUALS",
            },
          ],
        },
        "StartOnCreation": true,
        "Tags": Object {
          "SolutionId": "SOxyz",
        },
        "Type": "CONDITIONAL",
        "WorkflowName": Object {
          "Ref": "BackEndDataAnalysisAvaEtlWorkflowA035F2B6",
        },
      },
      "Type": "AWS::Glue::Trigger",
    },
    "BackEndExternalIntegrationsAnomalyDetectionBucketPolicy1101C4EE": Object {
      "Condition": "BackEndExternalIntegrationsAnomalyDetectionBucketCondition1F7AF011",
      "Properties": Object {
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "s3:GetObject",
              "Effect": "Allow",
              "Resource": Object {
                "Fn::Join": Array [
                  "",
                  Array [
                    "arn:",
                    Object {
                      "Ref": "AWS::Partition",
                    },
                    ":s3:::",
                    Object {
                      "Ref": "AnomalyDetectionBucketParameter",
                    },
                    "/*",
                  ],
                ],
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "PolicyName": "BackEndExternalIntegrationsAnomalyDetectionBucketPolicy1101C4EE",
        "Roles": Array [
          Object {
            "Ref": "BackEndExternalIntegrationsExternalIntegrationsLambdaRoleCB031580",
          },
        ],
      },
      "Type": "AWS::IAM::Policy",
    },
    "BackEndExternalIntegrationsConfigureBucketNotificationCustomResourceF938E975": Object {
      "Condition": "BackEndExternalIntegrationsAnomalyDetectionBucketCondition1F7AF011",
      "DeletionPolicy": "Delete",
      "DependsOn": Array [
        "BackEndExternalIntegrationsExternalIntegrationsIotToLambdaLambdaFunction80082192",
        "BackEndExternalIntegrationsSolutionHelperPutBucketNotificationPolicy81A866BA",
      ],
      "Properties": Object {
        "Action": "CONFIGURE_BUCKET_NOTIFICATION",
        "BucketName": Object {
          "Ref": "AnomalyDetectionBucketParameter",
        },
        "FunctionArn": Object {
          "Fn::GetAtt": Array [
            "BackEndExternalIntegrationsExternalIntegrationsIotToLambdaLambdaFunction80082192",
            "Arn",
          ],
        },
        "ServiceToken": Object {
          "Fn::GetAtt": Array [
            "CommonResourcesSolutionHelperSolutionHelperFunctionAFC2CF30",
            "Arn",
          ],
        },
      },
      "Type": "AWS::CloudFormation::CustomResource",
      "UpdateReplacePolicy": "Delete",
    },
    "BackEndExternalIntegrationsExternalIntegrationsIotToLambdaIotTopic37C76E94": Object {
      "Properties": Object {
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
        "TopicRulePayload": Object {
          "Actions": Array [
            Object {
              "Lambda": Object {
                "FunctionArn": Object {
                  "Fn::GetAtt": Array [
                    "BackEndExternalIntegrationsExternalIntegrationsIotToLambdaLambdaFunction80082192",
                    "Arn",
                  ],
                },
              },
            },
          ],
          "Description": "Messages from devices are sent to this topic for processing",
          "RuleDisabled": false,
          "Sql": "SELECT * FROM 'ava/devices'",
        },
      },
      "Type": "AWS::IoT::TopicRule",
    },
    "BackEndExternalIntegrationsExternalIntegrationsIotToLambdaLambdaFunction80082192": Object {
      "DependsOn": Array [
        "BackEndExternalIntegrationsExternalIntegrationsLambdaRoleDefaultPolicyC66F19E8",
        "BackEndExternalIntegrationsExternalIntegrationsLambdaRoleCB031580",
      ],
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "W58",
              "reason": "Lambda functions has the required permission to write CloudWatch Logs. It uses custom policy instead of arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole with tighter permissions.",
            },
            Object {
              "id": "W89",
              "reason": "This is not a rule for the general case, just for specific use cases/industries",
            },
            Object {
              "id": "W92",
              "reason": "Impossible for us to define the correct concurrency for clients",
            },
            Object {
              "id": "W89",
              "reason": "VPC for Lambda is not needed. This serverless architecture does not deploy a VPC.",
            },
            Object {
              "id": "W92",
              "reason": "ReservedConcurrentExecutions is not needed for this Lambda function.",
            },
          ],
        },
      },
      "Properties": Object {
        "Code": Object {
          "S3Bucket": Object {
            "Fn::Join": Array [
              "",
              Array [
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3BucketPrefix",
                  ],
                },
                "-",
                Object {
                  "Ref": "AWS::Region",
                },
              ],
            ],
          },
          "S3Key": Object {
            "Fn::Join": Array [
              "",
              Array [
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3KeyPrefix",
                  ],
                },
                "/external-integrations-handler.zip",
              ],
            ],
          },
        },
        "Description": "AVA Test (v3.0.0): Handles issues created by external integrations",
        "Environment": Object {
          "Variables": Object {
            "AWS_NODEJS_CONNECTION_REUSE_ENABLED": "1",
            "DATA_HIERARCHY_TABLE": Object {
              "Ref": "AVADataHierarchyTable",
            },
            "IOT_ENDPOINT_ADDRESS": Object {
              "Fn::GetAtt": Array [
                "CommonResourcesSolutionHelperGenerateSolutionConstants3C90DC87",
                "IotEndpointAddress",
              ],
            },
            "IOT_MESSAGE_NAME_DELIMITER": "/",
            "ISSUES_TABLE": Object {
              "Ref": "AVAIssuesTable",
            },
            "ISSUES_TOPIC": "ava/issues",
            "LOGGING_LEVEL": Object {
              "Ref": "LoggingLevel",
            },
            "SOLUTION_ID": "SOxyz",
            "SOLUTION_VERSION": "v3.0.0",
          },
        },
        "Handler": "external-integrations-handler/index.handler",
        "Role": Object {
          "Fn::GetAtt": Array [
            "BackEndExternalIntegrationsExternalIntegrationsLambdaRoleCB031580",
            "Arn",
          ],
        },
        "Runtime": "nodejs14.x",
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
        "Timeout": 60,
        "TracingConfig": Object {
          "Mode": "Active",
        },
      },
      "Type": "AWS::Lambda::Function",
    },
    "BackEndExternalIntegrationsExternalIntegrationsIotToLambdaLambdaFunctionAwsIotLambdaInvokePermission17B739EFB": Object {
      "Properties": Object {
        "Action": "lambda:InvokeFunction",
        "FunctionName": Object {
          "Fn::GetAtt": Array [
            "BackEndExternalIntegrationsExternalIntegrationsIotToLambdaLambdaFunction80082192",
            "Arn",
          ],
        },
        "Principal": "iot.amazonaws.com",
        "SourceArn": Object {
          "Fn::GetAtt": Array [
            "BackEndExternalIntegrationsExternalIntegrationsIotToLambdaIotTopic37C76E94",
            "Arn",
          ],
        },
      },
      "Type": "AWS::Lambda::Permission",
    },
    "BackEndExternalIntegrationsExternalIntegrationsIotToLambdaLambdaFunctionServiceRole5431E395": Object {
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "Service": "lambda.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "Policies": Array [
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": Array [
                    "logs:CreateLogGroup",
                    "logs:CreateLogStream",
                    "logs:PutLogEvents",
                  ],
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        "arn:",
                        Object {
                          "Ref": "AWS::Partition",
                        },
                        ":logs:",
                        Object {
                          "Ref": "AWS::Region",
                        },
                        ":",
                        Object {
                          "Ref": "AWS::AccountId",
                        },
                        ":log-group:/aws/lambda/*",
                      ],
                    ],
                  },
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "LambdaFunctionServiceRolePolicy",
          },
        ],
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "BackEndExternalIntegrationsExternalIntegrationsLambdaPermission079BFB8A": Object {
      "Condition": "BackEndExternalIntegrationsAnomalyDetectionBucketCondition1F7AF011",
      "Properties": Object {
        "Action": "lambda:InvokeFunction",
        "FunctionName": Object {
          "Ref": "BackEndExternalIntegrationsExternalIntegrationsIotToLambdaLambdaFunction80082192",
        },
        "Principal": "s3.amazonaws.com",
        "SourceAccount": Object {
          "Ref": "AWS::AccountId",
        },
        "SourceArn": Object {
          "Fn::Join": Array [
            "",
            Array [
              "arn:",
              Object {
                "Ref": "AWS::Partition",
              },
              ":s3:::",
              Object {
                "Ref": "AnomalyDetectionBucketParameter",
              },
            ],
          ],
        },
      },
      "Type": "AWS::Lambda::Permission",
    },
    "BackEndExternalIntegrationsExternalIntegrationsLambdaRoleCB031580": Object {
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "Service": "lambda.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "Path": "/",
        "Policies": Array [
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": "dynamodb:GetItem",
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::GetAtt": Array [
                      "AVADataHierarchyTable",
                      "Arn",
                    ],
                  },
                },
                Object {
                  "Action": "dynamodb:Query",
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        Object {
                          "Fn::GetAtt": Array [
                            "AVADataHierarchyTable",
                            "Arn",
                          ],
                        },
                        "/index/ByTypeAndParent-index",
                      ],
                    ],
                  },
                },
                Object {
                  "Action": "dynamodb:Query",
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        Object {
                          "Fn::GetAtt": Array [
                            "AVAIssuesTable",
                            "Arn",
                          ],
                        },
                        "/index/ByDeviceEvent-index",
                      ],
                    ],
                  },
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "DynamoDbPolicy",
          },
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": Array [
                    "logs:CreateLogGroup",
                    "logs:CreateLogStream",
                    "logs:PutLogEvents",
                  ],
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        "arn:",
                        Object {
                          "Ref": "AWS::Partition",
                        },
                        ":logs:",
                        Object {
                          "Ref": "AWS::Region",
                        },
                        ":",
                        Object {
                          "Ref": "AWS::AccountId",
                        },
                        ":log-group:/aws/lambda/*",
                      ],
                    ],
                  },
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "CloudWatchLogsPolicy",
          },
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": "iot:Publish",
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        "arn:",
                        Object {
                          "Ref": "AWS::Partition",
                        },
                        ":iot:",
                        Object {
                          "Ref": "AWS::Region",
                        },
                        ":",
                        Object {
                          "Ref": "AWS::AccountId",
                        },
                        ":topic/ava/issues",
                      ],
                    ],
                  },
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "IotPolicy",
          },
        ],
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "BackEndExternalIntegrationsExternalIntegrationsLambdaRoleDefaultPolicyC66F19E8": Object {
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "W12",
              "reason": "Lambda needs the following minimum required permissions to send trace data to X-Ray and access ENIs in a VPC.",
            },
          ],
        },
      },
      "Properties": Object {
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": Array [
                "xray:PutTraceSegments",
                "xray:PutTelemetryRecords",
              ],
              "Effect": "Allow",
              "Resource": "*",
            },
          ],
          "Version": "2012-10-17",
        },
        "PolicyName": "BackEndExternalIntegrationsExternalIntegrationsLambdaRoleDefaultPolicyC66F19E8",
        "Roles": Array [
          Object {
            "Ref": "BackEndExternalIntegrationsExternalIntegrationsLambdaRoleCB031580",
          },
        ],
      },
      "Type": "AWS::IAM::Policy",
    },
    "BackEndExternalIntegrationsSolutionHelperPutBucketNotificationPolicy81A866BA": Object {
      "Condition": "BackEndExternalIntegrationsAnomalyDetectionBucketCondition1F7AF011",
      "Properties": Object {
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": Array [
                "s3:GetBucketNotification",
                "s3:PutBucketNotification",
              ],
              "Effect": "Allow",
              "Resource": Object {
                "Fn::Join": Array [
                  "",
                  Array [
                    "arn:",
                    Object {
                      "Ref": "AWS::Partition",
                    },
                    ":s3:::",
                    Object {
                      "Ref": "AnomalyDetectionBucketParameter",
                    },
                  ],
                ],
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "PolicyName": "BackEndExternalIntegrationsSolutionHelperPutBucketNotificationPolicy81A866BA",
        "Roles": Array [
          Object {
            "Ref": "CommonResourcesSolutionHelperSolutionHelperFunctionRole5DBA041C",
          },
        ],
      },
      "Type": "AWS::IAM::Policy",
    },
    "BackEndHandleIssuesFunctionRoleCE098BAE": Object {
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "Service": "lambda.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "Path": "/",
        "Policies": Array [
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": "appsync:GraphQL",
                  "Effect": "Allow",
                  "Resource": Array [
                    Object {
                      "Fn::Join": Array [
                        "",
                        Array [
                          Object {
                            "Fn::GetAtt": Array [
                              "BackEndAppSyncApiGraphqlApi7F48FCAE",
                              "Arn",
                            ],
                          },
                          "/types/Mutation/fields/createIssue",
                        ],
                      ],
                    },
                    Object {
                      "Fn::Join": Array [
                        "",
                        Array [
                          Object {
                            "Fn::GetAtt": Array [
                              "BackEndAppSyncApiGraphqlApi7F48FCAE",
                              "Arn",
                            ],
                          },
                          "/types/Mutation/fields/updateIssue",
                        ],
                      ],
                    },
                  ],
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "GraphQLPolicy",
          },
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": "sns:Publish",
                  "Effect": "Allow",
                  "Resource": Object {
                    "Ref": "IssueNotificationTopic",
                  },
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "SnsPolicy",
          },
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": "dynamodb:GetItem",
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::GetAtt": Array [
                      "AVADataHierarchyTable",
                      "Arn",
                    ],
                  },
                },
                Object {
                  "Action": "dynamodb:Query",
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        Object {
                          "Fn::GetAtt": Array [
                            "AVAIssuesTable",
                            "Arn",
                          ],
                        },
                        "/index/ByDeviceEvent-index",
                      ],
                    ],
                  },
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "DynamoDbPolicy",
          },
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": Array [
                    "logs:CreateLogGroup",
                    "logs:CreateLogStream",
                    "logs:PutLogEvents",
                  ],
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        "arn:",
                        Object {
                          "Ref": "AWS::Partition",
                        },
                        ":logs:",
                        Object {
                          "Ref": "AWS::Region",
                        },
                        ":",
                        Object {
                          "Ref": "AWS::AccountId",
                        },
                        ":log-group:/aws/lambda/*",
                      ],
                    ],
                  },
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "CloudWatchLogsPolicy",
          },
        ],
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "BackEndHandleIssuesFunctionRoleDefaultPolicy8BD85679": Object {
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "W12",
              "reason": "Lambda needs the following minimum required permissions to send trace data to X-Ray and access ENIs in a VPC.",
            },
          ],
        },
      },
      "Properties": Object {
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": Array [
                "xray:PutTraceSegments",
                "xray:PutTelemetryRecords",
              ],
              "Effect": "Allow",
              "Resource": "*",
            },
          ],
          "Version": "2012-10-17",
        },
        "PolicyName": "BackEndHandleIssuesFunctionRoleDefaultPolicy8BD85679",
        "Roles": Array [
          Object {
            "Ref": "BackEndHandleIssuesFunctionRoleCE098BAE",
          },
        ],
      },
      "Type": "AWS::IAM::Policy",
    },
    "BackEndIoTResourcePolicyE7BCF8FC": Object {
      "Properties": Object {
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": Array [
                "iot:Publish",
              ],
              "Effect": "Allow",
              "Resource": Array [
                Object {
                  "Fn::Join": Array [
                    "",
                    Array [
                      "arn:",
                      Object {
                        "Ref": "AWS::Partition",
                      },
                      ":iot:",
                      Object {
                        "Ref": "AWS::Region",
                      },
                      ":",
                      Object {
                        "Ref": "AWS::AccountId",
                      },
                      ":topic/ava/issues",
                    ],
                  ],
                },
                Object {
                  "Fn::Join": Array [
                    "",
                    Array [
                      "arn:",
                      Object {
                        "Ref": "AWS::Partition",
                      },
                      ":iot:",
                      Object {
                        "Ref": "AWS::Region",
                      },
                      ":",
                      Object {
                        "Ref": "AWS::AccountId",
                      },
                      ":topic/ava/groups/*",
                    ],
                  ],
                },
              ],
            },
            Object {
              "Action": Array [
                "iot:Subscribe",
              ],
              "Effect": "Allow",
              "Resource": Array [
                Object {
                  "Fn::Join": Array [
                    "",
                    Array [
                      "arn:",
                      Object {
                        "Ref": "AWS::Partition",
                      },
                      ":iot:",
                      Object {
                        "Ref": "AWS::Region",
                      },
                      ":",
                      Object {
                        "Ref": "AWS::AccountId",
                      },
                      ":topicfilter/ava/groups/*",
                    ],
                  ],
                },
              ],
            },
            Object {
              "Action": Array [
                "iot:Receive",
              ],
              "Effect": "Allow",
              "Resource": Array [
                Object {
                  "Fn::Join": Array [
                    "",
                    Array [
                      "arn:",
                      Object {
                        "Ref": "AWS::Partition",
                      },
                      ":iot:",
                      Object {
                        "Ref": "AWS::Region",
                      },
                      ":",
                      Object {
                        "Ref": "AWS::AccountId",
                      },
                      ":topic/ava/groups/*",
                    ],
                  ],
                },
              ],
            },
            Object {
              "Action": Array [
                "iot:Connect",
              ],
              "Effect": "Allow",
              "Resource": Array [
                Object {
                  "Fn::Join": Array [
                    "",
                    Array [
                      "arn:",
                      Object {
                        "Ref": "AWS::Partition",
                      },
                      ":iot:",
                      Object {
                        "Ref": "AWS::Region",
                      },
                      ":",
                      Object {
                        "Ref": "AWS::AccountId",
                      },
                      ":client/*",
                    ],
                  ],
                },
              ],
            },
          ],
          "Version": "2012-10-17",
        },
      },
      "Type": "AWS::IoT::Policy",
    },
    "BackEndIotToLambdaIotTopic4E8A95F3": Object {
      "Properties": Object {
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
        "TopicRulePayload": Object {
          "Actions": Array [
            Object {
              "Lambda": Object {
                "FunctionArn": Object {
                  "Fn::GetAtt": Array [
                    "BackEndIotToLambdaLambdaFunctionA1095127",
                    "Arn",
                  ],
                },
              },
            },
          ],
          "Description": "Issues from the AVA Client are submitted to this topic and sent to lambda for processing",
          "RuleDisabled": false,
          "Sql": "SELECT * FROM 'ava/issues'",
        },
      },
      "Type": "AWS::IoT::TopicRule",
    },
    "BackEndIotToLambdaLambdaFunctionA1095127": Object {
      "DependsOn": Array [
        "BackEndHandleIssuesFunctionRoleDefaultPolicy8BD85679",
        "BackEndHandleIssuesFunctionRoleCE098BAE",
      ],
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "W58",
              "reason": "Lambda functions has the required permission to write CloudWatch Logs. It uses custom policy instead of arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole with tighter permissions.",
            },
            Object {
              "id": "W89",
              "reason": "This is not a rule for the general case, just for specific use cases/industries",
            },
            Object {
              "id": "W92",
              "reason": "Impossible for us to define the correct concurrency for clients",
            },
            Object {
              "id": "W89",
              "reason": "VPC for Lambda is not needed. This serverless architecture does not deploy a VPC.",
            },
            Object {
              "id": "W92",
              "reason": "ReservedConcurrentExecutions is not needed for this Lambda function.",
            },
          ],
        },
      },
      "Properties": Object {
        "Code": Object {
          "S3Bucket": Object {
            "Fn::Join": Array [
              "",
              Array [
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3BucketPrefix",
                  ],
                },
                "-",
                Object {
                  "Ref": "AWS::Region",
                },
              ],
            ],
          },
          "S3Key": Object {
            "Fn::Join": Array [
              "",
              Array [
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3KeyPrefix",
                  ],
                },
                "/ava-issue-handler.zip",
              ],
            ],
          },
        },
        "Description": "AVA Test (v3.0.0): Handles issues posted to the 'ava/issues' IoT Topic",
        "Environment": Object {
          "Variables": Object {
            "ACCOUNT_ID": Object {
              "Ref": "AWS::AccountId",
            },
            "API_ENDPOINT": Object {
              "Fn::GetAtt": Array [
                "BackEndAppSyncApiGraphqlApi7F48FCAE",
                "GraphQLUrl",
              ],
            },
            "AWS_NODEJS_CONNECTION_REUSE_ENABLED": "1",
            "DATA_HIERARCHY_TABLE": Object {
              "Ref": "AVADataHierarchyTable",
            },
            "ISSUES_TABLE": Object {
              "Ref": "AVAIssuesTable",
            },
            "ISSUE_NOTIFICATION_TOPIC_ARN": Object {
              "Ref": "IssueNotificationTopic",
            },
            "LOGGING_LEVEL": Object {
              "Ref": "LoggingLevel",
            },
            "SOLUTION_ID": "SOxyz",
            "SOLUTION_VERSION": "v3.0.0",
          },
        },
        "Handler": "ava-issue-handler/index.handler",
        "Role": Object {
          "Fn::GetAtt": Array [
            "BackEndHandleIssuesFunctionRoleCE098BAE",
            "Arn",
          ],
        },
        "Runtime": "nodejs14.x",
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
        "Timeout": 60,
        "TracingConfig": Object {
          "Mode": "Active",
        },
      },
      "Type": "AWS::Lambda::Function",
    },
    "BackEndIotToLambdaLambdaFunctionAwsIotLambdaInvokePermission13290C2B8": Object {
      "Properties": Object {
        "Action": "lambda:InvokeFunction",
        "FunctionName": Object {
          "Fn::GetAtt": Array [
            "BackEndIotToLambdaLambdaFunctionA1095127",
            "Arn",
          ],
        },
        "Principal": "iot.amazonaws.com",
        "SourceArn": Object {
          "Fn::GetAtt": Array [
            "BackEndIotToLambdaIotTopic4E8A95F3",
            "Arn",
          ],
        },
      },
      "Type": "AWS::Lambda::Permission",
    },
    "BackEndIotToLambdaLambdaFunctionServiceRole566D010B": Object {
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "Service": "lambda.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "Policies": Array [
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": Array [
                    "logs:CreateLogGroup",
                    "logs:CreateLogStream",
                    "logs:PutLogEvents",
                  ],
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        "arn:",
                        Object {
                          "Ref": "AWS::Partition",
                        },
                        ":logs:",
                        Object {
                          "Ref": "AWS::Region",
                        },
                        ":",
                        Object {
                          "Ref": "AWS::AccountId",
                        },
                        ":log-group:/aws/lambda/*",
                      ],
                    ],
                  },
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "LambdaFunctionServiceRolePolicy",
          },
        ],
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "CommonResourcesLogBucketFC1ABCC9": Object {
      "DeletionPolicy": "Retain",
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "W35",
              "reason": "This bucket is to store S3 and CloudFront logs, so it does not require to have logs for this bucket.",
            },
            Object {
              "id": "W51",
              "reason": "This bucket is to store S3 and CloudFront logs, so it does not require a bucket policy.",
            },
          ],
        },
      },
      "Properties": Object {
        "AccessControl": "LogDeliveryWrite",
        "BucketEncryption": Object {
          "ServerSideEncryptionConfiguration": Array [
            Object {
              "ServerSideEncryptionByDefault": Object {
                "SSEAlgorithm": "AES256",
              },
            },
          ],
        },
        "PublicAccessBlockConfiguration": Object {
          "BlockPublicAcls": true,
          "BlockPublicPolicy": true,
          "IgnorePublicAcls": true,
          "RestrictPublicBuckets": true,
        },
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::S3::Bucket",
      "UpdateReplacePolicy": "Retain",
    },
    "CommonResourcesSolutionHelperCopyWebsiteD6F96EA9": Object {
      "DeletionPolicy": "Delete",
      "Properties": Object {
        "Action": "COPY_WEBSITE",
        "DestinationBucket": Object {
          "Ref": "FrontEndDistributionToS3S3Bucket3A171D78",
        },
        "ServiceToken": Object {
          "Fn::GetAtt": Array [
            "CommonResourcesSolutionHelperSolutionHelperFunctionAFC2CF30",
            "Arn",
          ],
        },
        "SourceBucket": Object {
          "Fn::Join": Array [
            "",
            Array [
              Object {
                "Fn::FindInMap": Array [
                  "Solution",
                  "Config",
                  "S3BucketPrefix",
                ],
              },
              "-",
              Object {
                "Ref": "AWS::Region",
              },
            ],
          ],
        },
        "SourceKey": Object {
          "Fn::Join": Array [
            "",
            Array [
              Object {
                "Fn::FindInMap": Array [
                  "Solution",
                  "Config",
                  "S3KeyPrefix",
                ],
              },
              "/console",
            ],
          ],
        },
        "SourceManifest": "site-manifest.json",
        "WebsiteDistributionDomain": Object {
          "Fn::Join": Array [
            "",
            Array [
              "https://",
              Object {
                "Fn::GetAtt": Array [
                  "FrontEndDistributionToS3CloudFrontDistribution15FE13D0",
                  "DomainName",
                ],
              },
            ],
          ],
        },
      },
      "Type": "AWS::CloudFormation::CustomResource",
      "UpdateReplacePolicy": "Delete",
    },
    "CommonResourcesSolutionHelperCustomResourceLambdaIoTPolicy0595AC50": Object {
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "W12",
              "reason": "To connect IoT and attach IoT policy to Cognito identity cannot specify the specific resources.",
            },
          ],
        },
      },
      "Properties": Object {
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "iot:DetachPrincipalPolicy",
              "Effect": "Allow",
              "Resource": "*",
            },
          ],
          "Version": "2012-10-17",
        },
        "PolicyName": "CustomResourceLambdaIoTPolicy",
        "Roles": Array [
          Object {
            "Ref": "CommonResourcesSolutionHelperSolutionHelperFunctionRole5DBA041C",
          },
        ],
      },
      "Type": "AWS::IAM::Policy",
    },
    "CommonResourcesSolutionHelperGenerateSolutionConstants3C90DC87": Object {
      "DeletionPolicy": "Delete",
      "Properties": Object {
        "Action": "GENERATE_SOLUTION_CONSTANTS",
        "ServiceToken": Object {
          "Fn::GetAtt": Array [
            "CommonResourcesSolutionHelperGenerateSolutionConstantsFunction7191D09F",
            "Arn",
          ],
        },
      },
      "Type": "AWS::CloudFormation::CustomResource",
      "UpdateReplacePolicy": "Delete",
    },
    "CommonResourcesSolutionHelperGenerateSolutionConstantsFunction7191D09F": Object {
      "DependsOn": Array [
        "CommonResourcesSolutionHelperGenerateSolutionConstantsFunctionRoleED3C0929",
      ],
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "W89",
              "reason": "VPC for Lambda is not needed. This serverless architecture does not deploy a VPC.",
            },
            Object {
              "id": "W92",
              "reason": "ReservedConcurrentExecutions is not needed for this Lambda function.",
            },
          ],
        },
      },
      "Properties": Object {
        "Code": Object {
          "S3Bucket": Object {
            "Fn::Join": Array [
              "",
              Array [
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3BucketPrefix",
                  ],
                },
                "-",
                Object {
                  "Ref": "AWS::Region",
                },
              ],
            ],
          },
          "S3Key": Object {
            "Fn::Join": Array [
              "",
              Array [
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3KeyPrefix",
                  ],
                },
                "/solution-helper.zip",
              ],
            ],
          },
        },
        "Description": "AVA Test (v3.0.0): Generate Solution Constants",
        "Environment": Object {
          "Variables": Object {
            "LOGGING_LEVEL": Object {
              "Ref": "LoggingLevel",
            },
          },
        },
        "Handler": "solution-helper/index.handler",
        "Role": Object {
          "Fn::GetAtt": Array [
            "CommonResourcesSolutionHelperGenerateSolutionConstantsFunctionRoleED3C0929",
            "Arn",
          ],
        },
        "Runtime": "nodejs14.x",
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
        "Timeout": 60,
      },
      "Type": "AWS::Lambda::Function",
    },
    "CommonResourcesSolutionHelperGenerateSolutionConstantsFunctionRoleED3C0929": Object {
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "W11",
              "reason": "* is required for the iot:DescribeEndpoint permission",
            },
          ],
        },
      },
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "Service": "lambda.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "Path": "/",
        "Policies": Array [
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": Array [
                    "logs:CreateLogGroup",
                    "logs:CreateLogStream",
                    "logs:PutLogEvents",
                  ],
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        "arn:",
                        Object {
                          "Ref": "AWS::Partition",
                        },
                        ":logs:",
                        Object {
                          "Ref": "AWS::Region",
                        },
                        ":",
                        Object {
                          "Ref": "AWS::AccountId",
                        },
                        ":log-group:/aws/lambda/*",
                      ],
                    ],
                  },
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "CloudWatchLogsPolicy",
          },
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": "iot:DescribeEndpoint",
                  "Effect": "Allow",
                  "Resource": "*",
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "IoTPolicy",
          },
        ],
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "CommonResourcesSolutionHelperPutWebsiteConfig282170FD": Object {
      "DeletionPolicy": "Delete",
      "Properties": Object {
        "Action": "PUT_WEBSITE_CONFIG",
        "AndonWebsiteConfig": Object {
          "aws_appsync_authenticationType": "AMAZON_COGNITO_USER_POOLS",
          "aws_appsync_graphqlEndpoint": Object {
            "Fn::GetAtt": Array [
              "BackEndAppSyncApiGraphqlApi7F48FCAE",
              "GraphQLUrl",
            ],
          },
          "aws_appsync_region": Object {
            "Ref": "AWS::Region",
          },
          "aws_cognito_identity_pool_id": Object {
            "Ref": "FrontEndCognitoIdentityPool0FC7D25D",
          },
          "aws_cognito_region": Object {
            "Ref": "AWS::Region",
          },
          "aws_iot_endpoint": Object {
            "Fn::Join": Array [
              "",
              Array [
                "wss://",
                Object {
                  "Fn::GetAtt": Array [
                    "CommonResourcesSolutionHelperGenerateSolutionConstants3C90DC87",
                    "IotEndpointAddress",
                  ],
                },
              ],
            ],
          },
          "aws_iot_policy_name": Object {
            "Ref": "BackEndIoTResourcePolicyE7BCF8FC",
          },
          "aws_project_region": Object {
            "Ref": "AWS::Region",
          },
          "aws_user_pools_id": Object {
            "Ref": "FrontEndCognitoUserPoolFCECA826",
          },
          "aws_user_pools_web_client_id": Object {
            "Ref": "FrontEndCognitoUserPoolClientD6B239B2",
          },
          "default_language": Object {
            "Ref": "DefaultLanguage",
          },
          "solutions_metrics_endpoint": "https://metrics.awssolutionsbuilder.com/page",
          "solutions_send_metrics": Object {
            "Fn::FindInMap": Array [
              "Solution",
              "Config",
              "AnonymousUsage",
            ],
          },
          "solutions_solutionId": "SOxyz",
          "solutions_solutionUuId": Object {
            "Fn::GetAtt": Array [
              "CommonResourcesSolutionHelperGenerateSolutionConstants3C90DC87",
              "AnonymousDataUUID",
            ],
          },
          "solutions_version": "v3.0.0",
          "website_bucket": Object {
            "Ref": "FrontEndDistributionToS3S3Bucket3A171D78",
          },
        },
        "AndonWebsiteConfigFileBaseName": "andon_config",
        "S3Bucket": Object {
          "Ref": "FrontEndDistributionToS3S3Bucket3A171D78",
        },
        "ServiceToken": Object {
          "Fn::GetAtt": Array [
            "CommonResourcesSolutionHelperSolutionHelperFunctionAFC2CF30",
            "Arn",
          ],
        },
      },
      "Type": "AWS::CloudFormation::CustomResource",
      "UpdateReplacePolicy": "Delete",
    },
    "CommonResourcesSolutionHelperSolutionHelperFunctionAFC2CF30": Object {
      "DependsOn": Array [
        "CommonResourcesSolutionHelperSolutionHelperFunctionRoleDefaultPolicyFD9C8CEC",
        "CommonResourcesSolutionHelperSolutionHelperFunctionRole5DBA041C",
      ],
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "W89",
              "reason": "VPC for Lambda is not needed. This serverless architecture does not deploy a VPC.",
            },
            Object {
              "id": "W92",
              "reason": "ReservedConcurrentExecutions is not needed for this Lambda function.",
            },
          ],
        },
      },
      "Properties": Object {
        "Code": Object {
          "S3Bucket": Object {
            "Fn::Join": Array [
              "",
              Array [
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3BucketPrefix",
                  ],
                },
                "-",
                Object {
                  "Ref": "AWS::Region",
                },
              ],
            ],
          },
          "S3Key": Object {
            "Fn::Join": Array [
              "",
              Array [
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3KeyPrefix",
                  ],
                },
                "/solution-helper.zip",
              ],
            ],
          },
        },
        "Description": "AVA Test (v3.0.0): Solution Helper",
        "Environment": Object {
          "Variables": Object {
            "ANONYMOUS_DATA_UUID": Object {
              "Fn::GetAtt": Array [
                "CommonResourcesSolutionHelperGenerateSolutionConstants3C90DC87",
                "AnonymousDataUUID",
              ],
            },
            "LOGGING_LEVEL": Object {
              "Ref": "LoggingLevel",
            },
            "RETRY_SECONDS": "5",
            "SEND_ANONYMOUS_DATA": Object {
              "Fn::FindInMap": Array [
                "Solution",
                "Config",
                "AnonymousUsage",
              ],
            },
            "SOLUTION_ID": "SOxyz",
            "SOLUTION_VERSION": "v3.0.0",
          },
        },
        "Handler": "solution-helper/index.handler",
        "Role": Object {
          "Fn::GetAtt": Array [
            "CommonResourcesSolutionHelperSolutionHelperFunctionRole5DBA041C",
            "Arn",
          ],
        },
        "Runtime": "nodejs14.x",
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
        "Timeout": 60,
      },
      "Type": "AWS::Lambda::Function",
    },
    "CommonResourcesSolutionHelperSolutionHelperFunctionRole5DBA041C": Object {
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "Service": "lambda.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "Path": "/",
        "Policies": Array [
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": Array [
                    "logs:CreateLogGroup",
                    "logs:CreateLogStream",
                    "logs:PutLogEvents",
                  ],
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        "arn:",
                        Object {
                          "Ref": "AWS::Partition",
                        },
                        ":logs:",
                        Object {
                          "Ref": "AWS::Region",
                        },
                        ":",
                        Object {
                          "Ref": "AWS::AccountId",
                        },
                        ":log-group:/aws/lambda/*",
                      ],
                    ],
                  },
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "CloudWatchLogsPolicy",
          },
        ],
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "CommonResourcesSolutionHelperSolutionHelperFunctionRoleDefaultPolicyFD9C8CEC": Object {
      "Properties": Object {
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": Array [
                "s3:GetObject*",
                "s3:GetBucket*",
                "s3:List*",
              ],
              "Effect": "Allow",
              "Resource": Array [
                Object {
                  "Fn::Join": Array [
                    "",
                    Array [
                      "arn:",
                      Object {
                        "Ref": "AWS::Partition",
                      },
                      ":s3:::",
                      Object {
                        "Fn::FindInMap": Array [
                          "Solution",
                          "Config",
                          "S3BucketPrefix",
                        ],
                      },
                      "-",
                      Object {
                        "Ref": "AWS::Region",
                      },
                    ],
                  ],
                },
                Object {
                  "Fn::Join": Array [
                    "",
                    Array [
                      "arn:",
                      Object {
                        "Ref": "AWS::Partition",
                      },
                      ":s3:::",
                      Object {
                        "Fn::FindInMap": Array [
                          "Solution",
                          "Config",
                          "S3BucketPrefix",
                        ],
                      },
                      "-",
                      Object {
                        "Ref": "AWS::Region",
                      },
                      "/",
                      Object {
                        "Fn::FindInMap": Array [
                          "Solution",
                          "Config",
                          "S3KeyPrefix",
                        ],
                      },
                      "/*",
                    ],
                  ],
                },
              ],
            },
            Object {
              "Action": Array [
                "s3:PutObject*",
                "s3:Abort*",
              ],
              "Effect": "Allow",
              "Resource": Object {
                "Fn::Join": Array [
                  "",
                  Array [
                    Object {
                      "Fn::GetAtt": Array [
                        "FrontEndDistributionToS3S3Bucket3A171D78",
                        "Arn",
                      ],
                    },
                    "/*",
                  ],
                ],
              },
            },
            Object {
              "Action": "s3:PutBucketCors",
              "Effect": "Allow",
              "Resource": Object {
                "Fn::GetAtt": Array [
                  "FrontEndDistributionToS3S3Bucket3A171D78",
                  "Arn",
                ],
              },
            },
            Object {
              "Action": "iot:ListTargetsForPolicy",
              "Effect": "Allow",
              "Resource": Object {
                "Fn::Join": Array [
                  "",
                  Array [
                    "arn:",
                    Object {
                      "Ref": "AWS::Partition",
                    },
                    ":iot:",
                    Object {
                      "Ref": "AWS::Region",
                    },
                    ":",
                    Object {
                      "Ref": "AWS::AccountId",
                    },
                    ":policy/*",
                  ],
                ],
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "PolicyName": "CommonResourcesSolutionHelperSolutionHelperFunctionRoleDefaultPolicyFD9C8CEC",
        "Roles": Array [
          Object {
            "Ref": "CommonResourcesSolutionHelperSolutionHelperFunctionRole5DBA041C",
          },
        ],
      },
      "Type": "AWS::IAM::Policy",
    },
    "CommonResourcesSolutionHelperSolutionLifecycleFF1B537C": Object {
      "DeletionPolicy": "Delete",
      "Properties": Object {
        "Action": "SOLUTION_LIFECYCLE",
        "IotPolicyName": Object {
          "Ref": "BackEndIoTResourcePolicyE7BCF8FC",
        },
        "ServiceToken": Object {
          "Fn::GetAtt": Array [
            "CommonResourcesSolutionHelperSolutionHelperFunctionAFC2CF30",
            "Arn",
          ],
        },
        "SolutionParameters": Object {
          "AnomalyDetectionBucketParameterSet": Object {
            "Fn::If": Array [
              "anomalyDetectionBucketParameterSetCondition",
              "No",
              "Yes",
            ],
          },
          "CognitoDomainPrefixParameterSet": Object {
            "Fn::If": Array [
              "cognitoDomainPrefixParameterSetCondition",
              "No",
              "Yes",
            ],
          },
          "CognitoSAMLProviderMetadataUrlParameterSet": Object {
            "Fn::If": Array [
              "cognitoSAMLProviderMetadataUrlParameterSetCondition",
              "No",
              "Yes",
            ],
          },
          "CognitoSAMLProviderNameParameterSet": Object {
            "Fn::If": Array [
              "cognitoSAMLProviderNameParameterSetCondition",
              "No",
              "Yes",
            ],
          },
          "DefaultLanguage": Object {
            "Ref": "DefaultLanguage",
          },
          "LoggingLevel": Object {
            "Ref": "LoggingLevel",
          },
          "StartGlueWorkflow": Object {
            "Ref": "StartGlueWorkflow",
          },
        },
      },
      "Type": "AWS::CloudFormation::CustomResource",
      "UpdateReplacePolicy": "Delete",
    },
    "FrontEndAVACognitoPolicy179B97ED": Object {
      "Properties": Object {
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": Array [
                "cognito-idp:ListUsers",
                "cognito-idp:ListUsersInGroup",
                "cognito-idp:AdminGetUser",
                "cognito-idp:AdminListGroupsForUser",
                "cognito-idp:AdminCreateUser",
                "cognito-idp:AdminDeleteUser",
                "cognito-idp:AdminAddUserToGroup",
                "cognito-idp:AdminRemoveUserFromGroup",
              ],
              "Effect": "Allow",
              "Resource": Object {
                "Fn::GetAtt": Array [
                  "FrontEndCognitoUserPoolFCECA826",
                  "Arn",
                ],
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "PolicyName": "AVACognitoPolicy",
        "Roles": Array [
          Object {
            "Ref": "FrontEndIdentityPoolRole3B0EF954",
          },
        ],
      },
      "Type": "AWS::IAM::Policy",
    },
    "FrontEndAVAEventImagePolicy3C5CA89F": Object {
      "Properties": Object {
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": Array [
                "s3:GetObject",
                "s3:PutObject",
                "s3:DeleteObject",
              ],
              "Effect": "Allow",
              "Resource": Object {
                "Fn::Join": Array [
                  "",
                  Array [
                    Object {
                      "Fn::GetAtt": Array [
                        "FrontEndDistributionToS3S3Bucket3A171D78",
                        "Arn",
                      ],
                    },
                    "/public/event-images/*",
                  ],
                ],
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "PolicyName": "AVAEventImagePolicy",
        "Roles": Array [
          Object {
            "Ref": "FrontEndIdentityPoolRole3B0EF954",
          },
        ],
      },
      "Type": "AWS::IAM::Policy",
    },
    "FrontEndAVAIotPolicyFBACDF60": Object {
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "W12",
              "reason": "To connect IoT and attach IoT policy to Cognito identity cannot specify the specific resources.",
            },
          ],
        },
      },
      "Properties": Object {
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": Array [
                "iot:AttachPrincipalPolicy",
                "iot:Connect",
              ],
              "Effect": "Allow",
              "Resource": "*",
            },
            Object {
              "Action": "iot:Publish",
              "Effect": "Allow",
              "Resource": Array [
                Object {
                  "Fn::Join": Array [
                    "",
                    Array [
                      "arn:",
                      Object {
                        "Ref": "AWS::Partition",
                      },
                      ":iot:",
                      Object {
                        "Ref": "AWS::Region",
                      },
                      ":",
                      Object {
                        "Ref": "AWS::AccountId",
                      },
                      ":topic/ava/issues",
                    ],
                  ],
                },
                Object {
                  "Fn::Join": Array [
                    "",
                    Array [
                      "arn:",
                      Object {
                        "Ref": "AWS::Partition",
                      },
                      ":iot:",
                      Object {
                        "Ref": "AWS::Region",
                      },
                      ":",
                      Object {
                        "Ref": "AWS::AccountId",
                      },
                      ":topic/ava/groups/*",
                    ],
                  ],
                },
              ],
            },
            Object {
              "Action": "iot:Subscribe",
              "Effect": "Allow",
              "Resource": Object {
                "Fn::Join": Array [
                  "",
                  Array [
                    "arn:",
                    Object {
                      "Ref": "AWS::Partition",
                    },
                    ":iot:",
                    Object {
                      "Ref": "AWS::Region",
                    },
                    ":",
                    Object {
                      "Ref": "AWS::AccountId",
                    },
                    ":topicfilter/ava/groups/*",
                  ],
                ],
              },
            },
            Object {
              "Action": "iot:Receive",
              "Effect": "Allow",
              "Resource": Object {
                "Fn::Join": Array [
                  "",
                  Array [
                    "arn:",
                    Object {
                      "Ref": "AWS::Partition",
                    },
                    ":iot:",
                    Object {
                      "Ref": "AWS::Region",
                    },
                    ":",
                    Object {
                      "Ref": "AWS::AccountId",
                    },
                    ":topic/ava/groups/*",
                  ],
                ],
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "PolicyName": "AVAIotPolicy",
        "Roles": Array [
          Object {
            "Ref": "FrontEndIdentityPoolRole3B0EF954",
          },
        ],
      },
      "Type": "AWS::IAM::Policy",
    },
    "FrontEndAVAListEventImagePolicy7AEACBFC": Object {
      "Properties": Object {
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "s3:ListBucket",
              "Effect": "Allow",
              "Resource": Object {
                "Fn::GetAtt": Array [
                  "FrontEndDistributionToS3S3Bucket3A171D78",
                  "Arn",
                ],
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "PolicyName": "AVAListEventImagePolicy",
        "Roles": Array [
          Object {
            "Ref": "FrontEndIdentityPoolRole3B0EF954",
          },
        ],
      },
      "Type": "AWS::IAM::Policy",
    },
    "FrontEndAdminGroupAssignmentB768C381": Object {
      "Properties": Object {
        "GroupName": Object {
          "Ref": "FrontEndUserPoolAdminGroupF95B2095",
        },
        "UserPoolId": Object {
          "Ref": "FrontEndCognitoUserPoolFCECA826",
        },
        "Username": Object {
          "Ref": "FrontEndAdminUser9E173A10",
        },
      },
      "Type": "AWS::Cognito::UserPoolUserToGroupAttachment",
    },
    "FrontEndAdminUser9E173A10": Object {
      "Properties": Object {
        "DesiredDeliveryMediums": Array [
          "EMAIL",
        ],
        "ForceAliasCreation": true,
        "UserAttributes": Array [
          Object {
            "Name": "email",
            "Value": Object {
              "Ref": "AdministratorEmail",
            },
          },
          Object {
            "Name": "email_verified",
            "Value": "true",
          },
        ],
        "UserPoolId": Object {
          "Ref": "FrontEndCognitoUserPoolFCECA826",
        },
        "Username": Object {
          "Ref": "AdministratorEmail",
        },
      },
      "Type": "AWS::Cognito::UserPoolUser",
    },
    "FrontEndCognitoIdentityPool0FC7D25D": Object {
      "Properties": Object {
        "AllowUnauthenticatedIdentities": false,
        "CognitoIdentityProviders": Array [
          Object {
            "ClientId": Object {
              "Ref": "FrontEndCognitoUserPoolClientD6B239B2",
            },
            "ProviderName": Object {
              "Fn::GetAtt": Array [
                "FrontEndCognitoUserPoolFCECA826",
                "ProviderName",
              ],
            },
            "ServerSideTokenCheck": true,
          },
        ],
      },
      "Type": "AWS::Cognito::IdentityPool",
    },
    "FrontEndCognitoSAMLProvider3A7A9A4D": Object {
      "Condition": "FrontEndCognitoSAMLConditionCF14CDB1",
      "Properties": Object {
        "AttributeMapping": Object {
          "email": "email",
          "family_name": "lastName",
          "given_name": "firstName",
        },
        "ProviderDetails": Object {
          "MetadataURL": Object {
            "Ref": "CognitoSAMLProviderMetadataUrlParameter",
          },
        },
        "ProviderName": Object {
          "Ref": "CognitoSAMLProviderNameParameter",
        },
        "ProviderType": "SAML",
        "UserPoolId": Object {
          "Ref": "FrontEndCognitoUserPoolFCECA826",
        },
      },
      "Type": "AWS::Cognito::UserPoolIdentityProvider",
    },
    "FrontEndCognitoTriggerFunction9B55F185": Object {
      "Condition": "FrontEndCognitoSAMLConditionCF14CDB1",
      "DependsOn": Array [
        "FrontEndCognitoTriggerFunctionRoleE1F3DD17",
      ],
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "W89",
              "reason": "VPC for Lambda is not needed. This serverless architecture does not deploy a VPC.",
            },
            Object {
              "id": "W92",
              "reason": "ReservedConcurrentExecutions is not needed for this Lambda function.",
            },
          ],
        },
      },
      "Properties": Object {
        "Code": Object {
          "S3Bucket": Object {
            "Fn::Join": Array [
              "",
              Array [
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3BucketPrefix",
                  ],
                },
                "-",
                Object {
                  "Ref": "AWS::Region",
                },
              ],
            ],
          },
          "S3Key": Object {
            "Fn::Join": Array [
              "",
              Array [
                Object {
                  "Fn::FindInMap": Array [
                    "Solution",
                    "Config",
                    "S3KeyPrefix",
                  ],
                },
                "/cognito-trigger.zip",
              ],
            ],
          },
        },
        "Description": "AVA Test (v3.0.0): Cognito Trigger. Used when a new user is confirmed in the user pool to allow for custom actions to be taken",
        "Environment": Object {
          "Variables": Object {
            "LOGGING_LEVEL": Object {
              "Ref": "LoggingLevel",
            },
          },
        },
        "Handler": "cognito-trigger/index.handler",
        "Role": Object {
          "Fn::GetAtt": Array [
            "FrontEndCognitoTriggerFunctionRoleE1F3DD17",
            "Arn",
          ],
        },
        "Runtime": "nodejs14.x",
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
        "Timeout": 60,
      },
      "Type": "AWS::Lambda::Function",
    },
    "FrontEndCognitoTriggerFunctionPermissionD9EE1B20": Object {
      "Condition": "FrontEndCognitoSAMLConditionCF14CDB1",
      "Properties": Object {
        "Action": "lambda:InvokeFunction",
        "FunctionName": Object {
          "Ref": "FrontEndCognitoTriggerFunction9B55F185",
        },
        "Principal": "cognito-idp.amazonaws.com",
        "SourceArn": Object {
          "Fn::GetAtt": Array [
            "FrontEndCognitoUserPoolFCECA826",
            "Arn",
          ],
        },
      },
      "Type": "AWS::Lambda::Permission",
    },
    "FrontEndCognitoTriggerFunctionRoleE1F3DD17": Object {
      "Condition": "FrontEndCognitoSAMLConditionCF14CDB1",
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "Service": "lambda.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "Path": "/",
        "Policies": Array [
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": Array [
                    "logs:CreateLogGroup",
                    "logs:CreateLogStream",
                    "logs:PutLogEvents",
                  ],
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        "arn:",
                        Object {
                          "Ref": "AWS::Partition",
                        },
                        ":logs:",
                        Object {
                          "Ref": "AWS::Region",
                        },
                        ":",
                        Object {
                          "Ref": "AWS::AccountId",
                        },
                        ":log-group:/aws/lambda/*",
                      ],
                    ],
                  },
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "CloudWatchLogsPolicy",
          },
        ],
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "FrontEndCognitoUserPoolClientD6B239B2": Object {
      "Properties": Object {
        "AllowedOAuthFlows": Array [
          "code",
        ],
        "AllowedOAuthFlowsUserPoolClient": true,
        "AllowedOAuthScopes": Array [
          "phone",
          "email",
          "openid",
          "profile",
          "aws.cognito.signin.user.admin",
        ],
        "CallbackURLs": Array [
          Object {
            "Fn::Join": Array [
              "",
              Array [
                "https://",
                Object {
                  "Fn::GetAtt": Array [
                    "FrontEndDistributionToS3CloudFrontDistribution15FE13D0",
                    "DomainName",
                  ],
                },
                "/",
              ],
            ],
          },
        ],
        "ClientName": "ava-userpool-client",
        "GenerateSecret": false,
        "LogoutURLs": Array [
          Object {
            "Fn::Join": Array [
              "",
              Array [
                "https://",
                Object {
                  "Fn::GetAtt": Array [
                    "FrontEndDistributionToS3CloudFrontDistribution15FE13D0",
                    "DomainName",
                  ],
                },
                "/",
              ],
            ],
          },
        ],
        "PreventUserExistenceErrors": "ENABLED",
        "RefreshTokenValidity": 1440,
        "SupportedIdentityProviders": Object {
          "Fn::If": Array [
            "FrontEndCognitoSAMLConditionCF14CDB1",
            Array [
              "COGNITO",
              Object {
                "Ref": "CognitoSAMLProviderNameParameter",
              },
            ],
            Array [
              "COGNITO",
            ],
          ],
        },
        "TokenValidityUnits": Object {
          "RefreshToken": "minutes",
        },
        "UserPoolId": Object {
          "Ref": "FrontEndCognitoUserPoolFCECA826",
        },
      },
      "Type": "AWS::Cognito::UserPoolClient",
    },
    "FrontEndCognitoUserPoolFCECA826": Object {
      "DeletionPolicy": "Retain",
      "Properties": Object {
        "AccountRecoverySetting": Object {
          "RecoveryMechanisms": Array [
            Object {
              "Name": "verified_phone_number",
              "Priority": 1,
            },
            Object {
              "Name": "verified_email",
              "Priority": 2,
            },
          ],
        },
        "AdminCreateUserConfig": Object {
          "AllowAdminCreateUserOnly": true,
          "InviteMessageTemplate": Object {
            "EmailMessage": Object {
              "Fn::Join": Array [
                "",
                Array [
                  "<p>
                        You are invited to join Amazon Virtual Andon. Your temporary password is as follows:
                    </p>
                    <p>
                        E-Mail: <strong>{username}</strong><br />
                        Password: <strong>{####}</strong>
                    </p>
                    <p>
                        Please sign in to Amazon Virtual Andon with your Username (E-Mail) and temporary password provided above at:<br />
                        https://",
                  Object {
                    "Fn::GetAtt": Array [
                      "FrontEndDistributionToS3CloudFrontDistribution15FE13D0",
                      "DomainName",
                    ],
                  },
                  "
                    </p>",
                ],
              ],
            },
            "EmailSubject": "[AVA Test] - Login Information",
          },
        },
        "EmailVerificationMessage": "The verification code to your new account is {####}",
        "EmailVerificationSubject": "Verify your new account",
        "LambdaConfig": Object {
          "Fn::If": Array [
            "FrontEndCognitoSAMLConditionCF14CDB1",
            Object {
              "PostConfirmation": Object {
                "Fn::GetAtt": Array [
                  "FrontEndCognitoTriggerFunction9B55F185",
                  "Arn",
                ],
              },
            },
            Object {},
          ],
        },
        "Policies": Object {
          "PasswordPolicy": Object {
            "MinimumLength": 8,
            "RequireLowercase": true,
            "RequireNumbers": true,
            "RequireSymbols": true,
            "RequireUppercase": true,
            "TemporaryPasswordValidityDays": 7,
          },
        },
        "SmsVerificationMessage": "The verification code to your new account is {####}",
        "UserPoolAddOns": Object {
          "AdvancedSecurityMode": "ENFORCED",
        },
        "UserPoolName": "ava-userpool",
        "UserPoolTags": Object {
          "SolutionId": "SOxyz",
        },
        "VerificationMessageTemplate": Object {
          "DefaultEmailOption": "CONFIRM_WITH_CODE",
          "EmailMessage": "The verification code to your new account is {####}",
          "EmailSubject": "Verify your new account",
          "SmsMessage": "The verification code to your new account is {####}",
        },
      },
      "Type": "AWS::Cognito::UserPool",
      "UpdateReplacePolicy": "Retain",
    },
    "FrontEndDistributionToS3CloudFrontDistribution15FE13D0": Object {
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "W70",
              "reason": "Since the distribution uses the CloudFront domain name, CloudFront automatically sets the security policy to TLSv1 regardless of the value of MinimumProtocolVersion",
            },
          ],
        },
      },
      "Properties": Object {
        "DistributionConfig": Object {
          "Comment": "Website Distribution for Amazon Virtual Andon",
          "CustomErrorResponses": Array [
            Object {
              "ErrorCode": 403,
              "ResponseCode": 200,
              "ResponsePagePath": "/index.html",
            },
            Object {
              "ErrorCode": 404,
              "ResponseCode": 200,
              "ResponsePagePath": "/index.html",
            },
          ],
          "DefaultCacheBehavior": Object {
            "CachePolicyId": "658327ea-f89d-4fab-a63d-7e88639e58f6",
            "Compress": true,
            "TargetOriginId": "TestStackFrontEndDistributionToS3CloudFrontDistributionOrigin12FCDC222",
            "ViewerProtocolPolicy": "redirect-to-https",
          },
          "DefaultRootObject": "index.html",
          "Enabled": true,
          "HttpVersion": "http2",
          "IPV6Enabled": true,
          "Logging": Object {
            "Bucket": Object {
              "Fn::GetAtt": Array [
                "CommonResourcesLogBucketFC1ABCC9",
                "RegionalDomainName",
              ],
            },
            "Prefix": "hosting-cloudfront/",
          },
          "Origins": Array [
            Object {
              "DomainName": Object {
                "Fn::GetAtt": Array [
                  "FrontEndDistributionToS3S3Bucket3A171D78",
                  "RegionalDomainName",
                ],
              },
              "Id": "TestStackFrontEndDistributionToS3CloudFrontDistributionOrigin12FCDC222",
              "S3OriginConfig": Object {
                "OriginAccessIdentity": Object {
                  "Fn::Join": Array [
                    "",
                    Array [
                      "origin-access-identity/cloudfront/",
                      Object {
                        "Ref": "FrontEndDistributionToS3CloudFrontDistributionOrigin1S3OriginD10E575E",
                      },
                    ],
                  ],
                },
              },
            },
          ],
        },
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::CloudFront::Distribution",
    },
    "FrontEndDistributionToS3CloudFrontDistributionOrigin1S3OriginD10E575E": Object {
      "Properties": Object {
        "CloudFrontOriginAccessIdentityConfig": Object {
          "Comment": "Identity for TestStackFrontEndDistributionToS3CloudFrontDistributionOrigin12FCDC222",
        },
      },
      "Type": "AWS::CloudFront::CloudFrontOriginAccessIdentity",
    },
    "FrontEndDistributionToS3S3Bucket3A171D78": Object {
      "DeletionPolicy": "Retain",
      "Properties": Object {
        "BucketEncryption": Object {
          "ServerSideEncryptionConfiguration": Array [
            Object {
              "ServerSideEncryptionByDefault": Object {
                "SSEAlgorithm": "AES256",
              },
            },
          ],
        },
        "LifecycleConfiguration": Object {
          "Rules": Array [
            Object {
              "NoncurrentVersionTransitions": Array [
                Object {
                  "StorageClass": "GLACIER",
                  "TransitionInDays": 90,
                },
              ],
              "Status": "Enabled",
            },
          ],
        },
        "LoggingConfiguration": Object {
          "DestinationBucketName": Object {
            "Ref": "CommonResourcesLogBucketFC1ABCC9",
          },
          "LogFilePrefix": "hosting-s3/",
        },
        "PublicAccessBlockConfiguration": Object {
          "BlockPublicAcls": true,
          "BlockPublicPolicy": true,
          "IgnorePublicAcls": true,
          "RestrictPublicBuckets": true,
        },
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
        "VersioningConfiguration": Object {
          "Status": "Enabled",
        },
      },
      "Type": "AWS::S3::Bucket",
      "UpdateReplacePolicy": "Retain",
    },
    "FrontEndDistributionToS3S3BucketPolicyF3A0315A": Object {
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "F16",
              "reason": "Public website bucket policy requires a wildcard principal",
            },
          ],
        },
      },
      "Properties": Object {
        "Bucket": Object {
          "Ref": "FrontEndDistributionToS3S3Bucket3A171D78",
        },
        "PolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "*",
              "Condition": Object {
                "Bool": Object {
                  "aws:SecureTransport": "false",
                },
              },
              "Effect": "Deny",
              "Principal": Object {
                "AWS": "*",
              },
              "Resource": Array [
                Object {
                  "Fn::Join": Array [
                    "",
                    Array [
                      Object {
                        "Fn::GetAtt": Array [
                          "FrontEndDistributionToS3S3Bucket3A171D78",
                          "Arn",
                        ],
                      },
                      "/*",
                    ],
                  ],
                },
                Object {
                  "Fn::GetAtt": Array [
                    "FrontEndDistributionToS3S3Bucket3A171D78",
                    "Arn",
                  ],
                },
              ],
              "Sid": "HttpsOnly",
            },
            Object {
              "Action": "s3:GetObject",
              "Effect": "Allow",
              "Principal": Object {
                "CanonicalUser": Object {
                  "Fn::GetAtt": Array [
                    "FrontEndDistributionToS3CloudFrontDistributionOrigin1S3OriginD10E575E",
                    "S3CanonicalUserId",
                  ],
                },
              },
              "Resource": Object {
                "Fn::Join": Array [
                  "",
                  Array [
                    Object {
                      "Fn::GetAtt": Array [
                        "FrontEndDistributionToS3S3Bucket3A171D78",
                        "Arn",
                      ],
                    },
                    "/*",
                  ],
                ],
              },
            },
          ],
          "Version": "2012-10-17",
        },
      },
      "Type": "AWS::S3::BucketPolicy",
    },
    "FrontEndIdentityPoolRole3B0EF954": Object {
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRoleWithWebIdentity",
              "Condition": Object {
                "ForAnyValue:StringLike": Object {
                  "cognito-identity.amazonaws.com:amr": "authenticated",
                },
                "StringEquals": Object {
                  "cognito-identity.amazonaws.com:aud": Object {
                    "Ref": "FrontEndCognitoIdentityPool0FC7D25D",
                  },
                },
              },
              "Effect": "Allow",
              "Principal": Object {
                "Federated": "cognito-identity.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "Description": "Identity Pool Authenticated Role for AVA Test",
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::IAM::Role",
    },
    "FrontEndIdentityPoolRoleAttachmentE2CDACAA": Object {
      "Properties": Object {
        "IdentityPoolId": Object {
          "Ref": "FrontEndCognitoIdentityPool0FC7D25D",
        },
        "Roles": Object {
          "authenticated": Object {
            "Fn::GetAtt": Array [
              "FrontEndIdentityPoolRole3B0EF954",
              "Arn",
            ],
          },
        },
      },
      "Type": "AWS::Cognito::IdentityPoolRoleAttachment",
    },
    "FrontEndPutWebsiteConfigWithOAuthA1FE51D9": Object {
      "Condition": "FrontEndCognitoSAMLConditionCF14CDB1",
      "DeletionPolicy": "Delete",
      "DependsOn": Array [
        "CommonResourcesSolutionHelperPutWebsiteConfig282170FD",
      ],
      "Properties": Object {
        "Action": "PUT_WEBSITE_CONFIG",
        "AndonWebsiteConfig": Object {
          "aws_appsync_authenticationType": "AMAZON_COGNITO_USER_POOLS",
          "aws_appsync_graphqlEndpoint": Object {
            "Fn::GetAtt": Array [
              "BackEndAppSyncApiGraphqlApi7F48FCAE",
              "GraphQLUrl",
            ],
          },
          "aws_appsync_region": Object {
            "Ref": "AWS::Region",
          },
          "aws_cognito_identity_pool_id": Object {
            "Ref": "FrontEndCognitoIdentityPool0FC7D25D",
          },
          "aws_cognito_region": Object {
            "Ref": "AWS::Region",
          },
          "aws_iot_endpoint": Object {
            "Fn::Join": Array [
              "",
              Array [
                "wss://",
                Object {
                  "Fn::GetAtt": Array [
                    "CommonResourcesSolutionHelperGenerateSolutionConstants3C90DC87",
                    "IotEndpointAddress",
                  ],
                },
              ],
            ],
          },
          "aws_iot_policy_name": Object {
            "Ref": "BackEndIoTResourcePolicyE7BCF8FC",
          },
          "aws_project_region": Object {
            "Ref": "AWS::Region",
          },
          "aws_user_pools_id": Object {
            "Ref": "FrontEndCognitoUserPoolFCECA826",
          },
          "aws_user_pools_web_client_id": Object {
            "Ref": "FrontEndCognitoUserPoolClientD6B239B2",
          },
          "default_language": Object {
            "Ref": "DefaultLanguage",
          },
          "oauth": Object {
            "domain": Object {
              "Fn::Join": Array [
                "",
                Array [
                  Object {
                    "Ref": "FrontEndUserPoolDomain4D30EABB",
                  },
                  ".auth.",
                  Object {
                    "Ref": "AWS::Region",
                  },
                  ".amazoncognito.com",
                ],
              ],
            },
            "redirectSignIn": Object {
              "Fn::Join": Array [
                "",
                Array [
                  "https://",
                  Object {
                    "Fn::GetAtt": Array [
                      "FrontEndDistributionToS3CloudFrontDistribution15FE13D0",
                      "DomainName",
                    ],
                  },
                  "/",
                ],
              ],
            },
            "redirectSignOut": Object {
              "Fn::Join": Array [
                "",
                Array [
                  "https://",
                  Object {
                    "Fn::GetAtt": Array [
                      "FrontEndDistributionToS3CloudFrontDistribution15FE13D0",
                      "DomainName",
                    ],
                  },
                  "/",
                ],
              ],
            },
            "responseType": "code",
            "scope": Array [
              "phone",
              "email",
              "openid",
              "profile",
              "aws.cognito.signin.user.admin",
            ],
          },
          "solutions_metrics_endpoint": "https://metrics.awssolutionsbuilder.com/page",
          "solutions_send_metrics": Object {
            "Fn::FindInMap": Array [
              "Solution",
              "Config",
              "AnonymousUsage",
            ],
          },
          "solutions_solutionId": "SOxyz",
          "solutions_solutionUuId": Object {
            "Fn::GetAtt": Array [
              "CommonResourcesSolutionHelperGenerateSolutionConstants3C90DC87",
              "AnonymousDataUUID",
            ],
          },
          "solutions_version": "v3.0.0",
          "website_bucket": Object {
            "Ref": "FrontEndDistributionToS3S3Bucket3A171D78",
          },
        },
        "AndonWebsiteConfigFileBaseName": "andon_config",
        "S3Bucket": Object {
          "Ref": "FrontEndDistributionToS3S3Bucket3A171D78",
        },
        "ServiceToken": Object {
          "Fn::GetAtt": Array [
            "CommonResourcesSolutionHelperSolutionHelperFunctionAFC2CF30",
            "Arn",
          ],
        },
      },
      "Type": "AWS::CloudFormation::CustomResource",
      "UpdateReplacePolicy": "Delete",
    },
    "FrontEndUserPoolAdminGroupF95B2095": Object {
      "Properties": Object {
        "Description": "Admin group for Amazon Virtual Andon",
        "GroupName": "AdminGroup",
        "Precedence": 0,
        "UserPoolId": Object {
          "Ref": "FrontEndCognitoUserPoolFCECA826",
        },
      },
      "Type": "AWS::Cognito::UserPoolGroup",
    },
    "FrontEndUserPoolAssociateGroupE20CCB2B": Object {
      "Properties": Object {
        "Description": "Associate group for Amazon Virtual Andon",
        "GroupName": "AssociateGroup",
        "Precedence": 2,
        "UserPoolId": Object {
          "Ref": "FrontEndCognitoUserPoolFCECA826",
        },
      },
      "Type": "AWS::Cognito::UserPoolGroup",
    },
    "FrontEndUserPoolDomain4D30EABB": Object {
      "Condition": "FrontEndCognitoDomainPrefixConditionABB3BBB6",
      "Properties": Object {
        "Domain": Object {
          "Ref": "CognitoDomainPrefixParameter",
        },
        "UserPoolId": Object {
          "Ref": "FrontEndCognitoUserPoolFCECA826",
        },
      },
      "Type": "AWS::Cognito::UserPoolDomain",
    },
    "FrontEndUserPoolEngineerGroup63920F66": Object {
      "Properties": Object {
        "Description": "Engineer group for Amazon Virtual Andon",
        "GroupName": "EngineerGroup",
        "Precedence": 3,
        "UserPoolId": Object {
          "Ref": "FrontEndCognitoUserPoolFCECA826",
        },
      },
      "Type": "AWS::Cognito::UserPoolGroup",
    },
    "FrontEndUserPoolManagerGroup12099DAD": Object {
      "Properties": Object {
        "Description": "Manager group for Amazon Virtual Andon",
        "GroupName": "ManagerGroup",
        "Precedence": 1,
        "UserPoolId": Object {
          "Ref": "FrontEndCognitoUserPoolFCECA826",
        },
      },
      "Type": "AWS::Cognito::UserPoolGroup",
    },
    "IssueNotificationTopic": Object {
      "Properties": Object {
        "DisplayName": "Amazon Virtual Andon Notifications",
        "KmsMasterKeyId": Object {
          "Fn::Join": Array [
            "",
            Array [
              "arn:",
              Object {
                "Ref": "AWS::Partition",
              },
              ":kms:",
              Object {
                "Ref": "AWS::Region",
              },
              ":",
              Object {
                "Ref": "AWS::AccountId",
              },
              ":alias/aws/sns",
            ],
          ],
        },
        "Tags": Array [
          Object {
            "Key": "SolutionId",
            "Value": "SOxyz",
          },
        ],
      },
      "Type": "AWS::SNS::Topic",
    },
  },
}
`;

exports[`utils 1`] = `
Object {
  "Resources": Object {
    "TestTable1": Object {
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "abc",
              "reason": "mock reason",
            },
            Object {
              "id": "xyz",
              "reason": "mock reason",
            },
          ],
        },
      },
      "Type": "AWS::DynamoDB::Table",
    },
    "TestTable2BDBB502F": Object {
      "DeletionPolicy": "Retain",
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "xyz",
              "reason": "mock reason",
            },
          ],
        },
      },
      "Properties": Object {
        "AttributeDefinitions": Array [
          Object {
            "AttributeName": "name",
            "AttributeType": "S",
          },
        ],
        "KeySchema": Array [
          Object {
            "AttributeName": "name",
            "KeyType": "HASH",
          },
        ],
        "ProvisionedThroughput": Object {
          "ReadCapacityUnits": 5,
          "WriteCapacityUnits": 5,
        },
      },
      "Type": "AWS::DynamoDB::Table",
      "UpdateReplacePolicy": "Retain",
    },
  },
}
`;
